<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Embrace the trend">
<meta property="og:type" content="website">
<meta property="og:title" content="Shaclow&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Shaclow&#39;s Blog">
<meta property="og:description" content="Embrace the trend">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shaclow&#39;s Blog">
<meta name="twitter:description" content="Embrace the trend">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>Shaclow's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shaclow's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,my world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/hibernate4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/hibernate4/" itemprop="url">hibernate4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关联映射</p>
<p>单向N-1映射</p>
<p>无论是否单向还是双向都需要在N一端使用@ManyToOne修饰代表关联实体的属性</p>
<p>@ManyToOne</p>
<ul>
<li>cascade级联策略<ul>
<li>ALL所有持久化操作都级联到关联实体</li>
<li>MERGE merge操作级联到关联实体</li>
<li>PERSIST 指定将persist操作级联到关联实体</li>
<li>REFREASH 指定将refresh操作级联到关联实体</li>
<li>REMOVE 将remove操作级联到关联实体</li>
</ul>
</li>
<li>fetch 抓取策略  <ul>
<li>FetchType.EAGER 抓取实体，立即抓取关联实体，这是默认值</li>
<li>FetchType.LAZY 抓取实体时，延迟抓取，等到真正用到关联实体才去抓取</li>
</ul>
</li>
<li>optional 该属性指定的关联关系是否可选</li>
<li>targetEntity 该属性指定的关联实体的类名，默认是用反射来识别  一般来说如果是指向是N的话就要将其类型指出</li>
</ul>
<p>@JoinColumn 注解代表外键列 </p>
<p>一般处理关联关系的时候 一般分成 新建中间表和用外键列</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/hibernate学习（二）持久化类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/hibernate学习（二）持久化类/" itemprop="url">hibernate学习（二）持久化类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>持久化类使用和操作</p>
<p>持久化类的要求</p>
<ul>
<li>无参构造器，好像不一定要public 但至少包可见</li>
<li>标识属性，主键  最好用8种基本类型的包装类型，虽然用基本类型也行  这样方便</li>
<li>提供set和get方法</li>
<li>使用非final类  因为如果持久化类没实现接口，hibernate就使用javassist生成代理，这个代理对象是持久化类的子类实例   还有一个实现所有方法都是public的接口，此时使用jdk动态代理。避免声明public final 方法  如果必须要用public final 方法的类，用lazy=false禁用代理</li>
<li>重写equals 和 hashCode  如果将持久化类的实例放入set中就要提供这些方法，最常见的equals就是比较标识属性,但是如果是标识属性是自动生成的话不能比较标识属性，因为刚加进去的对象未被持久化是没有标识属性的，会在save的时候进行生成和分配</li>
</ul>
<p>持久化对象有三个情况</p>
<p>瞬态 持久化 脱管   （持久化和脱管可相互转换，脱管状态下的改变不会影响数据库，而持久化会）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">News n=<span class="keyword">new</span> News();</span><br><span class="line">n.setTitle(<span class="string">"xxx"</span>);</span><br><span class="line">n.setContent(<span class="string">"xxx"</span>);</span><br><span class="line">sess.save(n);       <span class="comment">//持久化类 将瞬态/脱管类保存在会话中</span></span><br></pre></td></tr></table></figure>
<p>在持久化的过程中，底层会生成一条insert语句</p>
<p>还有个persist()方法和save()一样，不过save()返回标识属性值，而persist不反悔，而且persist保证它在一个事务外部被调用的时候 并不立即转换为insert语句  这对需要封装长会话流程很有用</p>
<p>加载持久化实体  底层为seletct  + where 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">News n=sess.load(News.class,pk);   <span class="comment">//pk值是持久化实例的标识属性</span></span><br></pre></td></tr></table></figure>
<p>还有个get方法一样  不过get不支持延迟加载，若不存在就返回null  load支持延迟加载，若不存在对象返回一个未初始化的代理对象  延迟加载就是实际上使用对象的方法的时候才会真正向数据库加载</p>
<p>load和get还有 LockOptions 提供READ和UPGRADE代表共享 修改锁</p>
<p>还有用sess.buildLockRequest(LockOptions.xx).lock(n);来持久化的，不过要求这个n不能有修改，没啥用 </p>
<p>更新</p>
<ol>
<li><p>其实是加载持久化对象的基础上，调用方法进行修改然后再更新数据库中  更新的时候不用save，因为它就是持久化实体  用<code>sess.flush()</code></p>
</li>
<li><p>关闭会话后原来的持久化对象就脱管了，此时对其修改要保存到数据库中，需要重新创建session  然后<code>sess.update(n);</code>进行更新 类似的方法有merge 不过它的特定是不会持久化实例n，而是返回一个n的副本，该副本被持久化了 如果用merge保存程序对脱管对象做的修改时，如果会话有相同的持久化对象，merge提供的对象会覆盖它</p>
</li>
</ol>
<p>如果不知道这个对象是否持久化过，就用updateOrSave()方法就行</p>
<p>删除</p>
<p><code>sess.delete(n)</code></p>
<p>注意Session类不是平时用的tomcat的类 是hibernate的类 用来存储实例化类</p>
<h1 id="org-hibernate-resource-jdbc-internal-LogicalConnectionManagedImpl-21456e12-is-closed"><a href="#org-hibernate-resource-jdbc-internal-LogicalConnectionManagedImpl-21456e12-is-closed" class="headerlink" title="org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl@21456e12 is closed"></a>org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl@21456e12 is closed</h1><p>在调用session.close()的时候，该函数就已经将 trans.commit()执行了。所以最后一句代码显然就是多余的，将最后的trans.commit()这一句删除就好了。</p>
<p>所以想让脱离的对象重新持久化，那个事务要分开两个，因为中途会有session.close</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/hibernate3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/hibernate3/" itemprop="url">hibernate3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>深入理解Hibernate映射</p>
<p>@Entity 被该注释修饰的POJO就是一个实体，里面有属性如下</p>
<ul>
<li>name 指定实体类的名称，如果没有指定自动用类名作为实体类的名称</li>
</ul>
<p>@Table 指定持久化类映射的表</p>
<ul>
<li>name指定所映射表的表明，如果没指定就默认和持久化类的类名相同</li>
<li>index为持久化类所映射的表建立索引，该属性的值是一个@Index注解的数组</li>
</ul>
<p>@UniqueConstraint 用于为数据表定义唯一约束</p>
<ul>
<li>columnNames 该属性值一个字符串数组，每个字符串代表一个数据列</li>
</ul>
<p>唯一约束保证在一个字段或者一组字段（感觉是将一组字段是当作一个整体来比较）里的数据与表中其它行的数据相比是唯一的</p>
<p>@Index 用于数据表定义索引</p>
<ul>
<li>columnList 设置对哪些列建立索引，该属性值课指定多个数据列的列名</li>
<li>name 索引的名字</li>
<li>unique 该索引是否具有唯一性</li>
</ul>
<p>@Access 用于修改属性访问策略</p>
<ul>
<li><p>value值 AccessType.PROPERTY(默认) AccessType.FIELD 两个值</p>
<p>PROPERTY要使用set/get去访问属性值，FIELD则直接通过成员变量来访问属性（一般不建议）</p>
</li>
</ul>
<p>@Proxy 该注解的proxyClass属性指定一个接口，在延迟加载时作为代理使用，也可以在这里指定该类自己的名字</p>
<p>@DynamicInsert 指定insert语句是否在运行时动态生成，并只插入非空的字段，默认为false,因为这会降低性能</p>
<p>@DynamicUpdate 和上面差不多 可以指定乐观锁</p>
<p>@OptimisticLockType 乐观锁</p>
<ul>
<li>VERSION 检查version/timestamp字段   （推荐）</li>
<li>ALL 检查全部字段</li>
<li>DIRTY 只检查修改过的字段</li>
<li>NONE 不使用乐观锁定</li>
</ul>
<p>@SelectBeforeUpdate 指定Hibernate在update某个持久化对象前是否进行一次查询。如果该注解的value值设为true，则可以保证只有持久化对象状态被修改过才会update，若相同则不会update</p>
<p>@PolymorphismType 隐式多态循环¿</p>
<p>@Where </p>
<ul>
<li>clause 指定一个附加的SQL语句过滤条件(类似添加where子句)如果指定该注解，则不管采用load()/get()或其他查询方法，只要加载持久化类的对象时，这个where条件才生效，只有符合条件的记录才会被加载</li>
</ul>
<p>@BatchSize Hibernate抓取集合属性或延迟加载的实体，该注解的size属性指定每批抓取的实例数</p>
<p>@Check 可通过constraints属性制定一个sql表达，用于为该持久化类所对应的表指定一个check约束</p>
<p>@Subselect 该注解用于映射不可变、只读实体</p>
<h3 id="数据库映射"><a href="#数据库映射" class="headerlink" title="数据库映射"></a>数据库映射</h3><p>@Column 代表映射的具体的列</p>
<p>@Formula 该注解的value属性可以指定一个sql表达式 指定该属性值是由这个这个表达式计算的  该属性是动态计算的，<strong>不保存在数据库</strong></p>
<ol>
<li>表达式要加括号 </li>
<li>括号中的是SQL表达式，里面的列名和表名和数据库对应，不和持久化对象属性对应  可以用数据库内置的函数　</li>
<li>不过可以将属性作为参数传入到where这种东西里</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Formula</span>(<span class="string">"(select concat(nt.title,nt.content) from news_inf nt where nt.id=id)"</span>)</span><br><span class="line"><span class="keyword">private</span> String fullContent;                                              <span class="comment">//id是对象属性值</span></span><br></pre></td></tr></table></figure>
<p>我们可以从上述的代码可以看出这个fullcontent虽然是从数据库获取信息，但其实是在java代码中写好的。如果是要直接在数据库中生成数据，则可以用@Generated</p>
<p>@Generated 每当hibernate中执行一条insert(@Generated value是INSERT或者ALWAYS)或是update (@Generated value是ALWAYS) hibernante会执行一条select语句去获得该数据列的值并赋给实例对象的属性，而这个值实在数据库运算得出的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line"><span class="meta">@Generated</span>(GenerationTime.ALWAYS)</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"full_content"</span>)</span><br><span class="line"><span class="keyword">private</span> String fullContent;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> news_in(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">content</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    full_content <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"># 创建触发器</span><br><span class="line">DELIMITER |</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t_full_content_gen <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> news_inf</span><br><span class="line">	<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">set</span> new.full_content=<span class="keyword">concat</span>(new.title,new.content);</span><br><span class="line">	<span class="keyword">END</span>;</span><br><span class="line">|</span><br><span class="line">DELMITER;</span><br></pre></td></tr></table></figure>
<p>数据库中在MySQL中用<code>old</code>和<code>new</code>表示执行前和执行后的数据</p>
<p>在对new赋值的时候只能在触发器before中用 ，在after的触发器中，new的赋值已经结束了，只能读取内容。 如果使用after不能使用new赋值，只能取值，否则会出错误</p>
<p>old在用于取值？因为赋值没意义？</p>
<p>DELIMITER 的作用 设置结束符         比如DELIMITER | 则设置结束符为 |</p>
<p>告诉mysql解释器，当看到 |  的时候该段命令已经结束了，mysql可以执行了。默认情况下，delimiter是分号 ;</p>
<p>所以最后要 DELIMITER ; 将其结束符改回来</p>
<p>这样就在数据插入的时候触发触发器生成full_content列的数据，将其插入数据库中</p>
<p>但是咧，一定要实例化对象是保存在会话的时候才会进行数据库插入进行触发计算，所以如果在保存会话前取full_content是没有值的</p>
<p>@Transient 修饰不想持久保存的属性</p>
<p>默认情况下持久化类的属性都会映射到数据表中数据列，如果不想持久保存一些属性，可以用@Transient修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure>
<p>感觉这个和@Formula的区别是这个的数据不是自动生成的，可能需要对象某种方法赋值什么的</p>
<p>@Enumerated 修饰枚举类型的属性</p>
<p>这里的属性要是枚举类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Fruit&#123;</span><br><span class="line">    apple,banana,orange,grape</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于枚举来说，apple的枚举值可以用名称代表，也可用枚举值的序号0代表，同样底层数据库可以保存名字或者序号</p>
<p>EnumType.STRING 底层数据库保存枚举值的名称 EnumType.ORDINAL 保存的是枚举值的数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Enumerated</span> (EnumType.ORDINAL)</span><br><span class="line"><span class="meta">@Column</span> (name=<span class="string">"smallfruit"</span>)   <span class="comment">//保存数字</span></span><br><span class="line"><span class="keyword">private</span> Fruit aa;</span><br></pre></td></tr></table></figure>
<p>@Lob @Basic</p>
<p>@Lob 可以表示两种类型分别为数据库保存图片和文本</p>
<p>@Lob修饰的属性是 byte[] Byte[] java.io.Serializable时，它们会被映射成Blob类型，用于保存图片</p>
<p>@Lob修饰的属性是 char[] Character[] java.lang.String 他们会映射成Clob列 用来保存长文本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存图片</span></span><br><span class="line">File file=<span class="keyword">new</span> File(<span class="string">"aab.jpg"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] content=<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)file.length()];</span><br><span class="line"><span class="keyword">new</span> FileInputStream(file).read(content);       <span class="comment">//创建文件读入流将文件读入content数组中</span></span><br><span class="line">person.setPic(content);          <span class="comment">//存储在持久化对象的@lob修饰的byte数组</span></span><br><span class="line">sess.save(person);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>但实际上@Lob通常会配一个@Basic 因为这种大数据量的东西，如果每次都加载而不需要的话就会造成性能的极大损耗，所以采取<strong>延迟加载</strong>，只有真正需要该属性时才从数据库加载。</p>
<p>@Basic</p>
<ul>
<li>fetch 接收 FetchType.EAGER/LAZY 前者立即加载后者延时加载</li>
<li>optional 属性映射的数据列是否允许null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="meta">@Basic</span> (fetch=FetchType.LAZY)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] pic;</span><br></pre></td></tr></table></figure>
<p>@Temporal 修饰日期</p>
<p>对于日期，java基本上使用Date，但数据库有很多类型date time timestamp等</p>
<p>属性value支持 TemporalType.DATE/TIME/TIMESTAMP</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Temporal</span>(TemporalType.DATE)</span><br><span class="line"><span class="keyword">private</span> Date bbb;</span><br></pre></td></tr></table></figure>
<p>所以会出现数据截取的情况，比如TemporalType.DATE 只取日期的部分 TIME只取时间的部分</p>
<p>映射主键</p>
<p>建议为持久化类定义一个标识属性，这就是底层数据库中的主键</p>
<p>现代数据库建模理论都推荐 不要使用物理主键（甚至是联合主键）（带语义的列） 而是使用逻辑主键 则建立外键列则方便很多，主从表的约束关系清晰</p>
<p>根据之前的经验，我们是用@Id去修饰该实体的属性</p>
<p>由于逻辑主键没有意义，所以Hibernate可以为这种主键提供主键生成器，负责为每个持久化实例生成唯一的逻辑主键值，我们是使用@GeneratedValue</p>
<p>@GeneratedValue</p>
<ul>
<li>strategy <ul>
<li>GenerationType.AUTO 自动选择最适合底层数据库的主键生成策略 默认</li>
<li>GenerationType.IDENTITY 对mysql,sqlserver 选择自增长的主键生成策略</li>
<li>GenerationType.SEQUENCE 对于oracle数据库，选择基于sequence主键生成策略 （和@SequenceGenerator使用）</li>
<li>GenerationType.TABLE 使用辅助表来生成主键 和@TableGenerator配合使用</li>
</ul>
</li>
<li></li>
<li>generator GenerationType.SEQUENCE和GenerationType.TABLE 该属性引用@SequenceGenerator @TableGenerator所定义的生成器的名称</li>
</ul>
<p>@SequenceGenerator 定义生成器的配置</p>
<ul>
<li>name 主键生成器的名称</li>
<li>catalog schema 将底层的sequence放入指定catalog schema中</li>
<li>initialValue 指定Sequence的初始值</li>
<li>sequenceName 指定列的名称</li>
</ul>
<p>@TableGenerator 定义的主键生成器会在底层数据库中额外生成一个辅助表</p>
<ul>
<li>name</li>
<li>catalog schema</li>
<li>table 指定表名</li>
<li>pkColumnName 指定存放主键名</li>
<li>valueColumnName 指定主键值的列名</li>
<li>indexes 该属性值的是一个@Index数组，用于辅助表定义索引</li>
<li>uniqueConstraints 属性值@UniqueConstraint数组，用于为辅助表创建唯一约束</li>
</ul>
<p>反正这两个Generator定义了一个生成器后这个name要给到@GeneratedValue 注解的generator属性值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@TableGenerator</span>(name=<span class="string">"newsGen"</span>,table=<span class="string">"newidgen"</span>,pkColumnName=<span class="string">"gen_key"</span>, valueColumnName=<span class="string">"gen_value"</span>, pkColumnValue=<span class="string">"news_id"</span>)</span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy=GenerationType.TABLE,generator=<span class="string">"newsGen"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br></pre></td></tr></table></figure>
<p>创建了一个新表 newidgen 里面有两列 分别是两行gen_key gen_value  有一行gen_key的值为 news_id gen_value是自动生成的1</p>
<p>其实Sequence和Table主键生成器虽然允许你做一些配置，但实际上是已经是固定好生成器策略了，但实际上Hibernate还能支持其他的生成器和策略  </p>
<p>如果需要，则使用Hibernate 提供的@GenericGenerator       其实就是把其他别的统一定义为@GenericGenerator</p>
<ul>
<li>name 主键生成器名称</li>
<li>strategy 主键生成器的主键生成策略</li>
</ul>
<p>strategy 属性可以是自定义的主键生成类（需要实现Hibernate的IdentifierGenerator接口），也可以是Hibernate提供的 （奇了怪了这些定义好的为啥不各自分配一个注释？）</p>
<p>Hibernate提供的实现类</p>
<ul>
<li>IncrementGenerator 用数字类型添加主键 没有其他进程使用同一个数据库时使用</li>
<li>IdentityGenerator 实现自增长</li>
<li>SequenceStyleGenerator </li>
<li>。。。</li>
<li>UUIDGenerator 用UUID算法实现一个字符串类型的标识符</li>
<li>。。。。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"aa"</span>, strategy=<span class="string">"org.hibernate.id.xxxx"</span>)</span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"aa"</span>)</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>
<p>映射集合</p>
<p>Hibernate中持久化对象中的集合字段必须声明为接口，比如Set Collection List Map SortedSet SortedMap 甚至时自定义类型 （只要实现 UserCollectionType接口</p>
<p>Hibernate在持久化某个实例的时候，会自动把程序中的集合实现类替换成它自己的实现类，所以千万不要将集合属性转换为集合实现类HashMap等 但Set Map 可以</p>
<p>集合属性会跟随持久化对象持久化，当持久化对象删除时，集合属性的内容也会删，将集合从一个持久化对象移动到另一个对象，集合元素的数据记录也会从一个表移动到下一个</p>
<p>我们采用注解 @ElementCollection 进行标记</p>
<ul>
<li>fetch FetchType.LAZY/EAGER</li>
<li>targetClass 集合元素的类型</li>
</ul>
<p>由于集合元素常要保存另一个数据表，所以需要一个@CollectionTable 代表保存集合属性的表 和外键列 @JoinColumn</p>
<p>@CollectionTable</p>
<ul>
<li>name</li>
<li>catalog schema</li>
<li>indexes</li>
<li>joinColumns       该属性值实要一个注解为@JoinColumn 的数组/单个元素   每个元素映射一个外键列</li>
<li>uniqueConstraints</li>
</ul>
<p>@JoinColumn 定义外键列  常用的部分的  其实都是部分的属性</p>
<ul>
<li>name 外间列名字</li>
<li>columnDefinition 指定Hibernate使用该属性指定的SQL片段创建外键列</li>
<li>table 指定列所在数据表的表名</li>
<li>unique 是否为该列添加唯一约束</li>
<li>referencedColumnName 指定该列参照的主键列的列名</li>
</ul>
<p>存储集合类型分成三种 List  Set  Map</p>
<p>@OrderColumn 定义List和数组的索引</p>
<ul>
<li>集合元素是基本类型及其包装类型字符串日期 用@ElementCollection映射集合 并且用普通的@Column映射集合元素对应的列</li>
<li>集合元素是组件 （非持久化的类（复合类型））就用@Element Collection + @Embeddable 修饰非持久类</li>
<li>集合元素是关联的持久化实体，这时候就要用@OneToMany @ManyToMany 进行关联什么的</li>
</ul>
<p>下面是List作为属性的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=String.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"school_inf"</span>,joinColumn=<span class="meta">@JoinColumn</span>(name=<span class="string">"person_id"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"school_name"</span>)</span><br><span class="line"><span class="meta">@OrderColumn</span>(name=<span class="string">"list_order"</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; schools =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>从上面分析一下构建的思路</p>
<ol>
<li>@ElementCollection 首先表明下面是个集合属性 而且value targetClass 中可以指明集合元素中的类型</li>
<li>由于集合是要单独放在一个表中，所以要用@CollectionTable 构建表 name代表表名 joinColumn 指明外键，要注意这个外键是放在集合所在表中，name是取外键列的名字  但实际上是主表的哪一列呢？我猜测是默认取主键列！</li>
<li>设置@Column给自己的集合元素存放信息的列</li>
<li>@OrderColumn 由于是有序集合 添加一个索引列，它会自动帮你完成索引内容的填充</li>
<li>列集合属性要用接口来声明  但要用具体类实例化</li>
</ol>
<p>这样我们持久化什么之类以后          就会多一个school_inf表 表示集合  并且表中会让外键列和索引列作为联合主键</p>
<p>题外话有一种奇怪的打开Session方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session=HibernateUtil.currentSession();</span><br><span class="line">....</span><br><span class="line">HibernateUtil.closeSession();</span><br></pre></td></tr></table></figure>
<p>数组和List完全一样不过没搞明白的是它是<code>private String[]schools;</code>  并没有实例化？？？？？然后他说数组和List的区别在于数组的长度不可变？？</p>
<p>Set和List的区别也不大，就是Set不用设置@OrderColumn  Set其他和List一样 具体实例化是 <code>Set&lt;String&gt;ss=new HashSet&lt;&gt;()</code>  不过注意要再@Column中添加nullable=false  保证元素列不为空  因为Set的表由于没有索引列，则默认采取外键和元素列作为联合主键。如果没有这么写则该表没有主键</p>
<p>Map</p>
<ul>
<li>ElementCollection</li>
<li>CollectionTable</li>
<li>Column</li>
</ul>
<hr>
<ul>
<li>MapKeyColumn</li>
<li>MapKeyClass</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=Float.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"xx_inf"</span>,joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"xxid"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"aa"</span>)</span><br><span class="line"><span class="meta">@MapKeyColumn</span>(name=<span class="string">"aa_key"</span>)</span><br><span class="line"><span class="meta">@MapKeyClass</span>(String.class)</span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Float&gt;xxx=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Map表中取外键和key列作为联合主键</p>
<p>集合属性通常推荐使用 延迟加载策略，Hibernate对集合属性默认采用延迟加载，在某些情况下可以</p>
<p>@ElementCollection(fetch=FetchType.EAGER) 取消延迟加载</p>
<p>有序集合：集合元素可以根据key或index访问</p>
<p>无序集合：集合里的元素只能遍历</p>
<p>Hibernate </p>
<p>并不会立即更新该元素对应的数据行，因此对于Set集合而言，只有执行插入和删除操作时改变才有效</p>
<p>一般来说1-N的关联关系来说一般1会放弃控制权，所有的更新操作都会放在N一端进行处理。</p>
<p>而未初始化集合元素（从数据库中获取）情况下直接向List集合中添加新元素是正确的，总是可行的。然而Set不同，由于要保证元素不能重复，则要加入新元素时需要加载Set对象 性能就受到影响</p>
<p>Hibernate 删除集合的元素的时候如果删除全部元素，就直接整个集合delete就行，但如果是删剩下一条的话，就会一条条删然后就剩下那条。但其实其实作为开发者，你可以先delete整个集合然后再insert一条记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; tmp=person.getSchools();   <span class="comment">//返回一个String集合</span></span><br><span class="line">person.setSchools(<span class="keyword">null</span>);  <span class="comment">//调用delete删除person的关联的全部集合元素</span></span><br><span class="line"><span class="comment">//....对tmp这个List集合进行删除19个元素什么的</span></span><br><span class="line">person.setSchools(tmp);        <span class="comment">//进行insert的一个操作</span></span><br></pre></td></tr></table></figure>
<p>集合的元素可以当作“从属于”（感觉不是真正意义上的从属因为不是关联）主表的实体，所以主类的记录删除，集合中相应的记录也会删除。而且Hibernate无法直接加载和查询集合属性表的记录，必须先加载主类实体再通过主类实体去加载</p>
<h2 id="有序集合映射"><a href="#有序集合映射" class="headerlink" title="有序集合映射"></a>有序集合映射</h2><p>除了List，Hibernate SortedSet 和 SortedMap  两个有序集合，</p>
<ul>
<li><p>当需要映射这种有序集合必须 @SortNatural 或者 @SortComparator 注解 前者表明对集合元素采用默认的排序，后者则表明对集合元素采用自定义排序</p>
</li>
<li><p>@SortComparator 必须指定value 值为Comparator的实现类</p>
</li>
<li><p>而实例化SortedSet 和SortedMap 则用 TreeSet 和 TreeMap</p>
</li>
<li>其他的之前介绍的集合属性的注解也不能漏</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=String.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"person_id"</span>,joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"person_id"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"xxxvalue"</span>,nullable=<span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@SortNatural</span></span><br><span class="line"><span class="keyword">private</span> SortedSet&lt;String&gt; train=<span class="keyword">new</span> TreeSet&lt;&gt;();    </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是SortedMap 就要加上一些@MapKeyColumn  @MapKeyClass 这种 并且实例化为TreeMap</span></span><br></pre></td></tr></table></figure>
<p>其实所谓有序是按照插入顺序，先来的就排在前面 默认排序下（@SortNatural）</p>
<p>不过的话，要保证hibernate.cfg.xml 中的hbm2.auto属性为update，保证添加元素不会导致重建表</p>
<p>这样一个主类对象就可以添加多个集合元素并存储在表中</p>
<p>实际上我们如果想要集合所谓的字符比较排序的话 可以@OrderBy来进行注解</p>
<p>需要JDK 1.4以上 它实在SQL查询中进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=String.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"xx_inf"</span>,joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"xx_id"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"xxxvalue"</span>)</span><br><span class="line"><span class="meta">@OrderBy</span>(<span class="string">"xxxxvalue desc"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; tt=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>@OrderBy 导致的改变是在sql查询的时候添加了  order by xxxxvalue desc 子句</p>
<h3 id="映射表中建立对象"><a href="#映射表中建立对象" class="headerlink" title="映射表中建立对象"></a>映射表中建立对象</h3><p>如果希望在映射文件中创建删除触发器存储过程等数据库对象， 一般来说我们用不到映射文件因为我们是用注解的</p>
<p>注意映射文件不是hibernate.cfg.xml  而是创建某个类中定义的文件 比如     class A  对应的映射文件A.hbm.xml文件</p>
<p>看网上感觉<a href="http://blog.sina.com.cn/s/blog_86f4502c0101fm8l.html好像是一个映射文件就要一个类对应，所以就建个空类吧嘻嘻" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_86f4502c0101fm8l.html好像是一个映射文件就要一个类对应，所以就建个空类吧嘻嘻</a></p>
<p>这时候你就可以使用<code>&lt;database-object&gt;</code>标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.hbm.xml</span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span>   <span class="comment">&lt;!--这是根元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">database-object</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">create</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">create</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">drop</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">drop</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要在指定数据库方言下才有效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dialect-scope</span> <span class="attr">name</span>=<span class="string">"org.hibernate.MySQL5Dialect"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dialect-scope</span> <span class="attr">name</span>=<span class="string">"org.hibernate.MySQL5InnoDBDialect"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">database-object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>create中上的内容就是以完整的DDL的语句  要配上分号</p>
<p>比如创建一个表 创建一个触发器  create table test(xxname varchar(233));</p>
<p>而drop也定义了删除指定数据库对象的DDL   怀疑是drop一个表什么的</p>
<p>方法二 我们也可以不用create 和drop 直接在 <code>&lt;database-object&gt;</code>中 添加<code>&lt;definition class=&quot;xxx&quot;&gt;</code> 这个类必须实现 org.hibernate.mapping.AuxiliaryDatabaseObject 接口 它直到如何组织create 和drop命令</p>
<p>注意实际上我们在hibernate.cfg.xml文件中要指明映射文件</p>
<p><code>&lt;mapping resource=&quot;xxx/a.hbm.xml&quot;&gt;&lt;/mapping&gt;</code></p>
<p>而且注意修改属性</p>
<p><code>&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;</code></p>
<p>然后我们就按照之前的获取Configuration 然后创建什么SessionFactory 就行了 甚至不用获取一个session  在创建SessionFactory对象时就会生成映射文件对应的数据库对象</p>
<p>不过下面提供一个Hibernate 5.x 推荐的创建SessionFactory方式  前面是传统创建方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StandardServiceRegistry registry =<span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line">Metadata metadata=<span class="keyword">new</span> MetadataSources(registry).buildMetadata();</span><br><span class="line">metadata.buildSessionFactory();   <span class="comment">//采用Metadata去创建SessionFactory</span></span><br></pre></td></tr></table></figure>
<p>感觉有点点复杂 </p>
<p>EnumSet 是一个接口好像 然后是抽取这是一个高性能集合实现，比HashSet快得多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">要求元素必须是枚举类型</span></span><br></pre></td></tr></table></figure>
<p>每个EnumSet实例的所有元素必须是单个枚举类型的元素。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Java program to illustrate working of EnumSet and</span></span><br><span class="line"><span class="comment">// its functions.</span></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">enum</span> Gfg </span><br><span class="line">&#123;</span><br><span class="line">    CODE, LEARN, CONTRIBUTE, QUIZ, MCQ</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// create a set</span></span><br><span class="line">        EnumSet&amp;lt;Gfg&amp;gt; set1, set2, set3, set4;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// add elements</span></span><br><span class="line">        set1 = EnumSet.of(Gfg.QUIZ, Gfg.CONTRIBUTE, Gfg.LEARN, Gfg.CODE);</span><br><span class="line">        <span class="comment">//创建一个具有与指定枚举集相同元素类型的枚举集，最初包含此类型中未包含在指定集中的所有元素。</span></span><br><span class="line">        set2 = EnumSet.complementOf(set1); </span><br><span class="line">        <span class="comment">//创建一个包含指定元素类型中所有元素的枚举集</span></span><br><span class="line">        set3 = EnumSet.allOf(Gfg.class);</span><br><span class="line">        <span class="comment">//创建最初包含由两个指定端点定义的范围内的所有元素的枚举集</span></span><br><span class="line">        set4 = EnumSet.range(Gfg.CODE, Gfg.CONTRIBUTE);</span><br><span class="line">        System.out.println(<span class="string">"Set 1: "</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">"Set 2: "</span> + set2);</span><br><span class="line">        System.out.println(<span class="string">"Set 3: "</span> + set3);</span><br><span class="line">        System.out.println(<span class="string">"Set 4: "</span> + set4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Set <span class="number">1</span>: [CODE, LEARN, CONTRIBUTE, QUIZ]</span><br><span class="line">Set <span class="number">2</span>: [MCQ]</span><br><span class="line">Set <span class="number">3</span>: [CODE, LEARN, CONTRIBUTE, QUIZ, MCQ]</span><br><span class="line">Set <span class="number">4</span>: [CODE, LEARN, CONTRIBUTE]</span><br></pre></td></tr></table></figure>
<p>实际上如果只是将其根据映射文件来生成数据库对象 可以使用SchemaExport工具 而不一定要需要创建会话工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.hibernate.service.ServiceRegistry serviceRegistry = <span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line">Metadata metadata = <span class="keyword">new</span> MetadataSources(serviceRegistry).buildMetadata();</span><br><span class="line">SchemaExport schemaExport = <span class="keyword">new</span> SchemaExport();		schemaExport.create(EnumSet.of(TargetType.DATABASE), metadata);</span><br><span class="line"><span class="comment">//或者  我不知道这个是只给出文档不创建数据库 还是又创建数据库又创建文档，感觉像后者</span></span><br><span class="line"><span class="comment">//我想是的因为 create函数是只执行create table操作 而text是仅生成sql脚本而不生成实际对象</span></span><br><span class="line">schemaExport.setFormat(<span class="keyword">true</span>).setOutputFile(<span class="string">"news.sql"</span>).create(EnumSet.of(TargetType.SCRIPT),metadata);</span><br></pre></td></tr></table></figure>
<p>TargetType 是一个枚举类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">enum</span> TargetType &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// * Export to the database.   //感觉这个才是创建数据库的  （好像只是创建数据库？）</span></span><br><span class="line">    DATABASE,</span><br><span class="line">     <span class="comment">//* Write to a script file.</span></span><br><span class="line">    SCRIPT,</span><br><span class="line">     <span class="comment">//* Write to &#123;@link System#out&#125;   //输出屏幕的样子</span></span><br><span class="line">    STDOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上SchemaExport 甚至执行它的main函数，它提供很多不同的参数功能，我想这些在代码中有相应的函数</p>
<p>p430</p>
<p>组件属性 </p>
<p>就是作为一个类做其他类属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"person_inf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    xxxx</span><br><span class="line">    <span class="keyword">private</span> Name name;   <span class="comment">//name 是一个类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让name成为一个组件属性使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"person_firstname"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fitst;</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"person_secondname"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Parent</span></span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NAme</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        first=s1;</span><br><span class="line">        second=s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略setter和getter的东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过上面实例可以知道映射组件属性需要做到的几点</p>
<ul>
<li>@Embeddable  注释整个组件类</li>
<li>@Column 注释组件类中的属性，将来是将这些属性拆开成一列列数据而已</li>
<li>@Parent 这个挺特别的 组件类中要有一个主人类的一个对象指向的就是Name主人的实体，而且要用@Parent注释它，估计注释后到时就会给这个owner自动赋值</li>
</ul>
<p>然后使用过程中就当Name是person的一个普通属性即可</p>
<p>最后这个组件属性并不是另外创建一个表，而是将其内容拆开，其一个个属性成为一列列补充在person_inf 中</p>
<p>实际上也有另外一种注释方法，不在组件类中进行属性 直接在持久化类进行注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    xx</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">            <span class="meta">@AttributeOverride</span>(name=<span class="string">"first"</span>,column=<span class="meta">@Column</span>(name=<span class="string">"person_firstname"</span>))</span><br><span class="line">            <span class="meta">@AttributeOverride</span>(name=<span class="string">"second"</span>,column=<span class="meta">@Column</span>(name=<span class="string">"person_lastname"</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">   <span class="keyword">private</span> Name name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Embedded注解</p>
<p>@AttrbuteOverrides下包含多个@AttributeOverride 里面name指明属性名 column指明映射的列的名字</p>
<p>但我觉得是不是组件类不用说明@Parent了？？？</p>
<p>如果<strong>组件属性类中的属性有那种集合类型</strong> 其实就不用对他进行什么操作，之前怎么做就怎么安排</p>
<p>实际上我们从底层数据库是看不出 这个集合的数据表 是数据person类 还是属于name类的，但其实没关系，毕竟如果属于name的话也是属于person的</p>
<p><strong>集合属性的元素为类</strong></p>
<p>比如<code>private List&lt;Name&gt;x=new ArrayList&lt;&gt;();</code>  <code>private Map&lt;String,Name&gt;x=new HashMap&lt;&gt;();</code></p>
<p>其他照旧 讲一下区别   程序不在用@Column映射为保存集合元素 而是用@Embeddable修饰组件类（Name）</p>
<p>组件类该干嘛干嘛</p>
<p>这样底层表的区别是  集合的那个表 由一列表示值变成多列表示值</p>
<p><strong>组件作为Map的索引</strong></p>
<p>这个时候@Column就要重出江湖，因为组件类不充当值了，而@MapKeyClass 就最好要明确指明类型</p>
<p>而且由于作为Map的key，所以这个组件类除了各种注解什么的 还要重写 equals 和 hashCode方法</p>
<p>在底层的表中 Map的映射表 会将外键列和Name属性对应的多个列 组成联合主键</p>
<p><strong>组件作为复合(联合)主键</strong></p>
<p>作为复合主键，对于组件类有了更高的要求</p>
<ul>
<li>有无参数构造器</li>
<li>必须实现java.io.Serializable  其实也是实现boolean equals(Object obj) 和 int hashCode()</li>
<li>重写equals和hashCode方法，定义来区分对象的规则</li>
</ul>
<p>这里给出的组件类的注解是写在持久化类中 所以不知道组件类注解是否可行????????????????????</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@EmbeddedId</span>             <span class="comment">//不是@Embedded</span></span><br><span class="line">    <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">        xxxxx</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多列作为联合主键</strong></p>
<p>其实比起将一个组件属性类当作一个复合主键，让多个列形成联合主键这种情况更加常见</p>
<ul>
<li>持久化类实现 java.io.Serializable接口</li>
<li>实现hashCode()和equals(Object obj)</li>
<li>然后将你想要的普通属性加上@Id  如果是那些特殊的组件类的请看上面</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/自定义标签/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/自定义标签/" itemprop="url">自定义标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自定义标签</p>
<p>一个tld文件 一个特殊的实现类 一个标签的使用</p>
<p>类</p>
<ul>
<li><p>SimpleTagSupport接口的实现  （doTag()）</p>
</li>
<li><p>带属性的标签需要 get/set方法</p>
</li>
<li><p>getJspContext().getAttribute(xx,PageContext.xxxx_SCOPE) 可以获取jsp页面各种作用域的属性</p>
<ul>
<li>或者是 getJspContext().setAttribute(String,object)设置属性不过好像就是pageScope属性的</li>
</ul>
</li>
<li><p>getJspContext().getOut()获取Writer 输出页面</p>
</li>
<li><p>getJspBody().invoke(null) 输出标签体内的内容</p>
<ul>
<li>这有个很骚的操作 标签体为 ${pageScope.xxx} 然后在一个循环中一边 getJspContext().setAttribute(String,object)设置更改属性，一遍getJspBody().invoke(null)去输出，这样就能实现遍历</li>
<li>好像就算是<code>&lt;jsp:attribute name=&quot;xxx&quot;&gt;</code>标签包裹的的标签体作为属性，她在类里面也只是个JspFragment也只是能invoke而已</li>
</ul>
<p>还有动态属性这比较麻烦，二七</p>
</li>
</ul>
<p>tld文件</p>
<ul>
<li>放在WEB-INF文件夹下</li>
<li>taglib标签为根标签<ul>
<li>uri标签</li>
<li>tag标签<ul>
<li>name</li>
<li>tag-class</li>
<li>body-content</li>
<li>attribute<ul>
<li>name required fragment</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用标签</p>
<ul>
<li><code>&lt;%@taglib uri=&quot;&quot; prefix%&gt;</code>声明</li>
<li><code>&lt;前缀：tagname attributename=&quot;value&quot;&gt;</code></li>
<li>标签体做属性 用 jsp:attribute标签包裹</li>
</ul>
<p>传递集合的时候，只能通过session 属性进行获取传递</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/big-endian和little-endian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/big-endian和little-endian/" itemprop="url">big-endian和little-endian</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Big-endian 和 small-endian其实不是数据类型 是字节序的问题</p>
<p>其实和CPU有关，也和编程语言有关    比如数字 0x12345678</p>
<p>big-endian会在低位存放 12 而small-endian会在低位存放 78</p>
<p>big-endian 会在内存低位存数据高位  small-endian 会在内存低位存数据低位  </p>
<p>所有网络协议也都是采用big endian的方式来传输数据的。所以有时我们也会把big endian方式称之为网络字节序</p>
<p>C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据</p>
<p><strong>X86 系列 CPU都是 little－endian</strong> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/git简单入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/git简单入门/" itemprop="url">git简单入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>安装好git后，git 是作为命令中使用，但是在它给的客户端  中用给的信息更友好</p>
<p>建立本地仓库，其实还是先从一个简单的文件夹开始</p>
<p>我们知道之后的git操作都需要在git目录下操作，也就是本地仓库，所以建立一个本地仓库还是必不可少的</p>
<ul>
<li>git status  判断这个文件夹的情况，判断是否是仓库，仓库的一些基本信息等等</li>
<li>git init 将这个文件夹变成本地仓库  其实就是在里面加一个 .git文件夹  默认作为master分支</li>
</ul>
<p>如果在本地仓库文件夹中多了一些文件，其实这些文件不算是真正在仓库当中，因为他们相当于没有做清点记录的工作（Untracked files），不算真正入库。</p>
<p>需要两部操作进行真正入库</p>
<ul>
<li><p>git add 将你这些文件 tracked  这些文件的状态从untracked -&gt;  new file(将文件放入缓存区))等待最后的确认的提交</p>
<ul>
<li>git rm –cached + <code>&lt;file&gt;</code>   删除刚刚缓存的文件，  new file-&gt; untracked状态</li>
<li>git commit -m &lt;”信息xx”&gt;  git commit 代表确认提交       -m  + 信息 代表提交信息，当作一个提交的额外日志备注把</li>
</ul>
</li>
<li><p>git log  可以看到所有产生的commit记录        刚刚的  -m  的信息就会出现在提交记录中</p>
</li>
</ul>
<p>git init 完自动生成主分支 master </p>
<ul>
<li>git branch  查看现在分支列表</li>
<li>git branch + name   建立新分支</li>
<li>git checkout + name 切换分支</li>
</ul>
<p>git checkout -b name  新键加切换一步到胃</p>
<p>分支合并</p>
<pre><code>1. checkout master 分支
2. git merge branchname 
</code></pre><p>很有趣，在一个本地仓库中创建文件，在一个分支中将其commit上去，git log 显示是head-&gt;branch1   但是在master分支就见不到对这个新文件  待提交</p>
<p>git merge 后这个 git log 就会显示  这个commit      (Head -&gt; branch1  master )</p>
<p>git branch -d    branchname     删除分支   在合并完分支后经常会考虑这个操作</p>
<p>如果 git merge 有冲突 这样会导致 git branch -d 失败，这时候要强势关掉分支  要用  git branch -D</p>
<p>如果git branch  的分支是代码的横向变化的化</p>
<p>那么git tag 标签是代码的纵向变化，它允许在一个分支中建立多个标签 当你代码出问题 你就可以回到过去拉哈哈</p>
<p>git tag tagname 就会在你当前代码建立一个标签</p>
<p>git checkout tagname 就可以切换标签</p>
<p>了解了本地仓库的操作后，就能和远程仓库有互动啦，，我们的远程仓库选择github   配置好ssh的东西就ok了</p>
<ul>
<li><p>git push 将本地代码推到远程仓库 </p>
<p>git push origin master    将本地代码推到远程的master分支</p>
</li>
<li><p>git pull  将远程仓库的代码拉到本地仓库</p>
<p>git pull origin master     </p>
</li>
</ul>
<p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p>
<p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;[:&lt;远程分支名&gt;]    </p>
<p>e.g., git push oschina master， 省略远程分支名，代表推送到有追踪关系的远程分支（一般为同名）</p>
<p>如果你是这个项目的楞头青你可以将其  git clone +地址  （具体看github上的地址）将整个项目复制下来，而这个新的文件夹本身就变成一个库，且和remote连接好了  默认这个remote仓库的名字叫 origin </p>
<p>Git 从 <code>2.9.0</code> 版本开始，预设行为不允许合并没有共同祖先的分支，需要加上 <code>--allow-unrelated-histories</code> 进行 pull 操作才不会出现此类错误信息。<br>例：<code>git pull --allow-unrelated-histories</code></p>
<p>git branch -r 能看到远程分支</p>
<p><strong>FETCH_HEAD：</strong> 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p>
<p>git pull : 首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。</p>
<p>有时候删除remote branch 在本地 branch -r 没有显示更新</p>
<p> git remote update origin –prune，更新。这里要注意下，如果你的remote branch不是在origin下，按你得把origin换成你的名字。</p>
<p>一些经验或疑惑</p>
<p>注意  git push 的时候 冒号前面千万别加空格 否则就是删除相应的远程repo</p>
<p>如果pull的时候不行，可以尝试  git pull -f强制覆盖  还想也是因为项目文件比较少，你的文件比较多的原因</p>
<p>一般来说 如果是push 到remote repo 的代码 你是无权删除它的  所以你push一个缺少文件的项目是不被允许的 不过你可以 push -f强制覆盖就很变态</p>
<p>git diff 可以看到差异   比较两次commit   缓存区和版本的文件  两个分支  的差异</p>
<p>git checkout 除了切换分支 切换标签 甚至可以切换到某次commit </p>
<p>git checkout + commit_id  (在 git log 中可以看到)</p>
<p>git  checkout 还能撤销m没有add到缓存区中的文件的修改</p>
<p>git stash 当你手头上有些代码没写完 ，此时你有紧急任务必须要立刻修复bug并立刻发布，这时候你不希望你没写完的代码随着bug修复的时候commit上去</p>
<p>这时候 你采用 git stash 命令，将当前分支所有没有commit的代码全部收容起来，</p>
<p>然后你可以在 git stash list 中可以看到收容的记录   </p>
<p>然后你可以做你修复的事情，然后回来做之前的功能 这时候就要 git stash apply 代码就回来了 但记录没删除</p>
<p>然后将缓存区的stash记录删除  git stash drop </p>
<p>git stash pop 这个是还原加记录删除</p>
<p>但是这个删除只是删除记录中的最近一条，实际上drop 中可以加  stash_id </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/正则表达式/" itemprop="url">正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p>？ 代表0或1个字符</p>
<p>*代表0或多个字符</p>
<p>^ 匹配输入字符串的开始位置</p>
<p>[0-9] 匹配单个数字 + 匹配一个或多个</p>
<p>abc$ 匹配字母abc并以abc结尾 $撇皮字符串的结束位置</p>
<p>^[a-z0-9_-]{3,15}$ </p>
<p>^匹配开始   [] 匹配 字母数字 下划线和连接字符   {3，15}$ 指定字符串的长度为3-15个  </p>
<p>+号 代表前面的字符 至少出现一次 </p>
<p>runoo+b  =&gt;  runooooooooob runoob</p>
<p>runoo*b 可以出现0次或更多</p>
<p>runoo?b  出现一次或0次</p>
<p>转义字符</p>
<table>
<thead>
<tr>
<th>\cx</th>
<th>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</th>
</tr>
</thead>
<tbody>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
</tbody>
</table>
<p>元字符就是特殊字符</p>
<p>如果要真正当作正常字符匹配他们 前面加 \</p>
<table>
<thead>
<tr>
<th>$</th>
<th>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \ $。</th>
</tr>
</thead>
<tbody>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>指明两项之间的一个选择。</td>
</tr>
</tbody>
</table>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
<p>贪婪与最小匹配</p>
<p><strong>*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配</strong></p>
<p>通过在 *、+  限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。</p>
<h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。</p>
<table>
<thead>
<tr>
<th>^</th>
<th>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配。</td>
</tr>
</tbody>
</table>
<p>感觉\b \B 表现很奇怪   \b可以表示一个单词后面的空格前面为止的匹配，\B就很奇怪  不奇怪</p>
<p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\Bapt/</span><br></pre></td></tr></table></figure>
<p>而且好像他们不能和$组合一起</p>
<p>而且所谓的^ 和$ 其实是代表行首和行尾懂8</p>
<p>捕获缓存</p>
<p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>
<p>可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>
<p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。</p>
<p>var str = “Is is the cost of of gasoline going up up”; var patt1 = /\b([a-z]+) \1\b/ig; document.write(str.match(patt1));</p>
<p>Is is,of of,up up</p>
<p>捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。</p>
<p>单词边界元字符确保只检测整个单词。否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。</p>
<p>正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。</p>
<p>表达式的结尾处的不区分大小写 i 标记指定不区分大小写。</p>
<p>多行标记指定换行符的两边可能出现潜在的匹配。</p>
<p>反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：</p>
<p>. 特殊字符在中括号表达式时 如 [.] 只会匹配 .字符，等价于 .，而非匹配除换行符 <strong>\n</strong> 外的所有字符。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/奇奇怪怪js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/奇奇怪怪js/" itemprop="url">奇奇怪怪js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>奇奇怪怪js</p>
<p>牛牛皮皮<code>&lt;iframe src=&quot;xxx.html&quot; width=&quot;500px&quot; height=&quot;300px&quot;&gt;</code>可以将一个页面的内容嵌套进来</p>
<p>他可以多层嵌套，嵌套层接嵌套</p>
<p>而window.location.href可以跳转你当前 页面  parent.location.href可以跳转你上一个父页面  top.location.href可以跳转你最顶层页面，被跳转的父页面下的所有的嵌套页面自然会随之消失的啦</p>
<p>window.location.href 和alert弹框会互相无阻碍执行，如果希望alert弹框能阻碍跳转 应该用其他弹框</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/数据库常识2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/数据库常识2/" itemprop="url">数据库常识2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-DDL-Data-Definition-Language"><a href="#1-DDL-Data-Definition-Language" class="headerlink" title="1. DDL - Data Definition Language"></a>1. DDL - Data Definition Language</h3><p>数据库定义语言：定义数据库的结构。</p>
<p>其主要命令有CREATE，ALTER，DROP等，该语言不需要commit，因此慎重。</p>
<p>还有其他的：</p>
<p>TRUNCATE - 截断表内容（开发期，还是挺常用的）</p>
<p>COMMENT - 为数据字典添加备注</p>
<h3 id="2-DML-Data-Manipulation-Language"><a href="#2-DML-Data-Manipulation-Language" class="headerlink" title="2. DML - Data Manipulation Language"></a>2. DML - Data Manipulation Language</h3><p>数据库操作语言：SQL中处理数据库中的数据</p>
<p>其主要命令有INSERT,UPDATE,DELETE等，这些例子大家常用就不一一介绍了。该语言需要commit。还</p>
<p>有常用的 LOCK TABLE ,记得写过锁的博客 - <a href="http://www.bysocket.com/?p=191" target="_blank" rel="noopener">传送门</a></p>
<p>还有其他不熟悉的：</p>
<p>CALL - 调用一个PL/SQL或Java子程序<br>EXPLAIN PLAN - 解析分析数据访问路径</p>
<h3 id="3-DCL-Data-Control-Language"><a href="#3-DCL-Data-Control-Language" class="headerlink" title="3. DCL - Data Control Language"></a>3. DCL - Data Control Language</h3><p>数据库控制语言：授权，角色控制等</p>
<p>GRANT - 为用户赋予访问权限</p>
<p>REVOKE - 撤回授权权限</p>
<h3 id="4-TCL-Transaction-Control-Language"><a href="#4-TCL-Transaction-Control-Language" class="headerlink" title="4. TCL - Transaction Control Language"></a>4. TCL - Transaction Control Language</h3><p>事务控制语言</p>
<p>COMMIT - 保存已完成的工作</p>
<p>SAVEPOINT - 在事务中设置保存点，可以回滚到此处</p>
<p>ROLLBACK - 回滚</p>
<p>SET TRANSACTION - 改变事务选项</p>
<p>有一种说法是将 select  where 这种说是DQL  但也有一种说法是归于DML中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/利用CookieManager管理Cookie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/利用CookieManager管理Cookie/" itemprop="url">利用CookieManager管理Cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:48+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen JianLun</p>
              <p class="site-description motion-element" itemprop="description">Embrace the trend</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen JianLun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
