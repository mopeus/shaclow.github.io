<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Embrace the trend">
<meta property="og:type" content="website">
<meta property="og:title" content="Shaclow&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Shaclow&#39;s Blog">
<meta property="og:description" content="Embrace the trend">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shaclow&#39;s Blog">
<meta name="twitter:description" content="Embrace the trend">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Shaclow's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shaclow's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,my world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JDBC(五)数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JDBC(五)数据类型/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th>SQL类型</th>
<th>JDBC/Java类型</th>
<th>setXXX</th>
<th>updateXXX</th>
</tr>
</thead>
<tbody>
<tr>
<td>VARCHAR</td>
<td>java.lang.String</td>
<td>setString</td>
<td>getString</td>
</tr>
<tr>
<td>CHAR</td>
<td>java.lang.String</td>
<td>setString</td>
<td>getString</td>
</tr>
<tr>
<td>LONGVARCHAR</td>
<td>java.lang.String</td>
<td>setString</td>
<td>getString</td>
</tr>
<tr>
<td>BIT</td>
<td>boolean</td>
<td>setBoolean</td>
<td>getBoolean</td>
</tr>
<tr>
<td>NUMERIC</td>
<td>java.math.BigDecimal</td>
<td>setBigDecimal</td>
<td>getBigDecimal</td>
</tr>
<tr>
<td>TINYINT</td>
<td>byte</td>
<td>setByte</td>
<td>getByte</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>short</td>
<td>setShort</td>
<td>getShort</td>
</tr>
<tr>
<td>INTEGER</td>
<td>int</td>
<td>setInt</td>
<td>getInt</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>setLong</td>
<td>getLong</td>
</tr>
<tr>
<td>REAL</td>
<td>float</td>
<td>setFloat</td>
<td>getFloat</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>setFloat</td>
<td>getFloat</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>setDouble</td>
<td>getDouble</td>
</tr>
<tr>
<td>VARBINARY</td>
<td>byte[ ]</td>
<td>setBytes</td>
<td>getBytes</td>
</tr>
<tr>
<td>BINARY</td>
<td>byte[ ]</td>
<td>setBytes</td>
<td>getBytes</td>
</tr>
<tr>
<td>DATE</td>
<td>java.sql.Date</td>
<td>setDate</td>
<td>getDate</td>
</tr>
<tr>
<td>TIME</td>
<td>java.sql.Time</td>
<td>setTime</td>
<td>getTime</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>java.sql.Timestamp</td>
<td>setTimestamp</td>
<td>getTimestamp</td>
</tr>
<tr>
<td>CLOB</td>
<td>java.sql.Clob</td>
<td>setClob</td>
<td>getClob</td>
</tr>
<tr>
<td>BLOB</td>
<td>java.sql.Blob</td>
<td>setBlob</td>
<td>getBlob</td>
</tr>
<tr>
<td>ARRAY</td>
<td>java.sql.Array</td>
<td>setARRAY</td>
<td>getARRAY</td>
</tr>
<tr>
<td>REF</td>
<td>java.sql.Ref</td>
<td>SetRef</td>
<td>getRef</td>
</tr>
<tr>
<td>STRUCT</td>
<td>java.sql.Struct</td>
<td>SetStruct</td>
<td>getStruct</td>
</tr>
</tbody>
</table>
<p>但即使这样好像也能强制转换为 String那种</p>
<h2 id="处理NULL值"><a href="#处理NULL值" class="headerlink" title="处理NULL值"></a>处理NULL值</h2><p>SQL使用<code>NULL</code>值和Java使用<code>null</code>是不同的概念。 所以，要在Java中处理SQL <code>NULL</code>值，可以使用三种策略 -</p>
<ul>
<li>避免使用返回原始数据类型的<code>getXXX()</code>方法。</li>
<li>对原始数据类型使用包装类，并使用<code>ResultSet</code>对象的<code>wasNull()</code>方法来测试接收<code>getXXX()</code>方法的返回值的包装器类变量是否应设置为<code>null</code>。</li>
<li>使用原始数据类型和<code>ResultSet</code>对象的<code>wasNull()</code>方法来测试接收到由<code>getXXX()</code>方法返回的值的原始变量是否应设置为表示<code>NULL</code>的可接受值。</li>
</ul>
<p>下面是一个用来处理<code>NULL</code>值的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">String sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>( rs.wasNull( ) ) &#123;</span><br><span class="line">   id = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JSP杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JSP杂谈/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>针对JSP 这种 自动解释html标签的情况 我们可以使用 转移字符 &lt; 来表示相应的尖括号</p>
<p>EL中隐式参数的使用 </p>
<p>param 和 paramValues </p>
<p>比如${param.name}  name对应表单中input的 name属性 </p>
<p>当一个表单中有多个input对应同一个name这时候通过param来识别是远远不够的</p>
<p>这时候 采用 ${paramValues.name[]} paramValues 返回一个name数组你就根据顺序找到 对应的数组元素</p>
<p>这个 可建立一个jsp进行实验</p>
<p>我们需要从头部获取信息 这儿时候采用隐式对象header可以实现  比如 ${header.host}  或者 ${header[“host”]}  倘若有多个值对应的首部 可以采用 headerValues 工作原理和paramValues相同</p>
<p>得到request的性质 比如他的请求返回方法  比如 post get这种 </p>
<p>我们可以用 scriptlet 这种 实现 &lt;%=request.getMethod()%&gt;     但是对于EL他没有request对象 requestscope也不是得到request对象本身的信息 他只是会得到请求的属性</p>
<p>无法处理的事情交给pageContext 去得到剩下的一切</p>
<p>${pageContext.request.method}   通过pageContext 就可以得到request对象了？</p>
<p>如果你是想获得特定作用域的属性  请在属性名前 加上所属的作用于 比如 ${requestScope.person.name}  倘若你不是加作用域 他就按之前所讲的顺序遍历作用域 直到找到所要的属性</p>
<p>但倘若属性名写得不规范  比如 setAttribute(“foo.person”,p);   ${foo.person.name} 这种是错误的   因为程序会寻找一个叫foo的作用域    所以要采用 ${requestScope[“foo.person”].name}</p>
<p>通过EL得到cookie和初始化参数</p>
<p>我们可以采用脚本 request.getCookies();  然后遍历cookies数组 找到对应的cookie</p>
<p>但EL 可以采用  ${cookie.userName.value}  只需要提供名字就可以找到相应的值</p>
<p>上下文初始化 </p>
<p>可以通过 &lt;%=application.getInitParameter(“xxx”)%&gt;     ${initParam.xxx}   注意initParam 对应是 application的参数 不是某个 config的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/js 和 jsp变量的传递/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/js 和 jsp变量的传递/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js 和 jsp变量的传递</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">"&lt;%= xxxList%&gt;"</span>;         </span><br><span class="line"><span class="comment">//传递list值直接传递 不过一定要加双引号，这能避免很多莫名其妙的麻烦</span></span><br><span class="line"><span class="comment">//比如你如果是纯数字可以不加，但其他比如字符串什么的一定要加</span></span><br><span class="line"><span class="keyword">var</span> id=<span class="string">"&lt;%= request.getAttribute("</span>xxxParam<span class="string">")%&gt;"</span>;</span><br><span class="line">&lt;% <span class="built_in">String</span> s=<span class="string">"abc"</span>;%&gt;</span><br><span class="line"><span class="keyword">var</span> s=<span class="string">"&lt;%= s%&gt;"</span>;</span><br></pre></td></tr></table></figure>
<p>注意传递数组的时候  不能像list那样直接传递给js变量 这样得到的值是java.lang.String</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在js和jsp页面中巧妙交换实现数组传递</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">&lt;% <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;archiveArr.length;i++)&#123;%&gt;</span><br><span class="line">    arr[<span class="xml"><span class="tag">&lt;<span class="name">%=i%</span>&gt;</span>]="<span class="tag">&lt;<span class="name">%=archiveArr[i]%</span>&gt;</span>";   //<span class="tag">&lt;<span class="name">%=</span> <span class="attr">i</span>%&gt;</span>中i是纯数字所以加不加双引号没所谓</span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">%&#125;%</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>jsp使用js定义的变量，只能使用js代码，将对应的变量放到表单里面或通过url（window.open拼接上变量）的方式。传递给jsp.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JDBC/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDBC代表Java数据库连接(<strong>J</strong>ava <strong>D</strong>ata<strong>b</strong>ase <strong>C</strong>onnectivity)，它是用于Java编程语言和数据库之间的数据库无关连接的标准Java API，换句话说：JDBC是用于在Java语言编程中与数据库连接的API。</p>
<p>JDBC库包括通常与数据库使用相关，如下面提到的每个任务的API -</p>
<p>从根本上说，JDBC是一个规范，它提供了一整套接口，允许以一种可移植的访问底层数据库API。 Java可以用它来编写不同类型的可执行文件，如 -</p>
<ul>
<li>Java应用程序</li>
<li>Java Applet</li>
<li>Java Servlets</li>
<li>Java ServerPages(<a href="http://www.yiibai.com/jsp/" target="_blank" rel="noopener">JSP</a>)</li>
<li>企业级JavaBeans(EJB)</li>
</ul>
<p>所有这些不同的可执行文件都能够使用JDBC驱动程序来访问数据库，并用于存储数据到数据库中。</p>
<p>JDBC提供与ODBC相同的功能，允许Java程序包含与数据库无关的代码(同样的代码，只需要指定使用的数据库类型，不需要重修改数据库查询或操作代码)。</p>
<h2 id="JDBC架构"><a href="#JDBC架构" class="headerlink" title="JDBC架构"></a>JDBC架构</h2><p>JDBC API支持用于数据库访问的两层和三层处理模型，但通常，JDBC体系结构由两层组成：</p>
<ul>
<li>JDBC API：提供应用程序到JDBC管理器连接。</li>
<li>JDBC驱动程序API：支持JDBC管理器到驱动程序连接。</li>
</ul>
<p>JDBC API使用驱动程序管理器并指定数据库的驱动程序来提供与异构数据库的透明连接。</p>
<p>JDBC驱动程序管理器确保使用正确的驱动程序来访问每个数据源。 驱动程序管理器能够支持连接到多个异构数据库的多个并发驱动程序。</p>
<p><img src="http://www.yiibai.com/uploads/images/201705/3005/659080547_64242.jpg" alt="img"></p>
<h2 id="常见的JDBC组件"><a href="#常见的JDBC组件" class="headerlink" title="常见的JDBC组件"></a>常见的JDBC组件</h2><p>JDBC API提供以下接口和类 </p>
<ul>
<li><code>DriverManager</code>：此类管理数据库驱动程序列表。 使用通信子协议将来自java应用程序的连接请求与适当的数据库驱动程序进行匹配。在JDBC下识别某个子协议的第一个驱动程序将用于建立数据库连接。</li>
<li><code>Driver</code>：此接口处理与数据库服务器的通信。我们很少会直接与<code>Driver</code>对象进行交互。 但会使用<code>DriverManager</code>对象来管理这种类型的对象。 它还提取与使用<code>Driver</code>对象相关的信息。</li>
<li><code>Connection</code>：此接口具有用于联系数据库的所有方法。 连接(<code>Connection</code>)对象表示通信上下文，即，与数据库的所有通信仅通过连接对象。</li>
<li><code>Statement</code>：使用从此接口创建的对象将SQL语句提交到数据库。 除了执行存储过程之外，一些派生接口还接受参数。</li>
<li><code>ResultSet</code>：在使用<code>Statement</code>对象执行SQL查询后，这些对象保存从数据库检索的数据。 它作为一个迭代器并可移动<code>ResultSet</code>对象查询的数据。</li>
<li><code>SQLException</code>：此类处理数据库应用程序中发生的任何错误。</li>
</ul>
<h2 id="JDBC-4-0包"><a href="#JDBC-4-0包" class="headerlink" title="JDBC 4.0包"></a>JDBC 4.0包</h2><p><code>java.sql</code>和<code>javax.sql</code>是JDBC 4.0的主要包。这是编写本教程时最新的JDBC版本。 它提供了与数据源进行交互的主要类。</p>
<h2 id="DBC驱动程序是什么？"><a href="#DBC驱动程序是什么？" class="headerlink" title="DBC驱动程序是什么？"></a><strong>DBC驱动程序是什么？</strong></h2><p>JDBC驱动程序在JDBC API中实现定义的接口，用于与数据库服务器进行交互。</p>
<p>例如，使用JDBC驱动程序，可以通过发送SQL或数据库命令，然后使用Java接收结果来打开数据库连接并与数据库进行交互。</p>
<p>JDK附带的<code>Java.sql</code>包包含各种类，其类的行为被定义，实现在第三方驱动程序中完成。 第三方供应商在其数据库驱动程序中实现<code>java.sql.Driver</code>接口。</p>
<h2 id="JDBC驱动程序类型"><a href="#JDBC驱动程序类型" class="headerlink" title="JDBC驱动程序类型"></a>JDBC驱动程序类型</h2><p>JDBC驱动程序实现因Java运行的各种操作系统和硬件平台而异。 Sun将实现类型分为四种类型，分别为<code>1</code>,<code>2</code>,<code>3`</code>4`类型，如下所述：</p>
<h3 id="类型1：JDBC-ODBC桥驱动程序"><a href="#类型1：JDBC-ODBC桥驱动程序" class="headerlink" title="类型1：JDBC-ODBC桥驱动程序"></a>类型1：JDBC-ODBC桥驱动程序</h3><p>在<strong>类型1</strong>驱动程序中，JDBC桥接器用于访问安装在每台客户机上的ODBC驱动程序。 使用ODBC需要在系统上配置表示目标数据库的数据源名称(DSN)。</p>
<p>当Java第一次出现时，这是一个驱动程序，因为大多数数据库仅支持ODBC访问，但现在这种类型的驱动程序仅推荐用于实验性使用或没有其他替代方案时使用。</p>
<p><img src="http://www.yiibai.com/uploads/images/201705/3005/696110505_18575.jpg" alt="img"></p>
<p><strong>JDK 1.2</strong>附带的JDBC-ODBC桥接是这种驱动程序的一个很好的例子。</p>
<h3 id="类型2：JDBC本地API"><a href="#类型2：JDBC本地API" class="headerlink" title="类型2：JDBC本地API"></a>类型2：JDBC本地API</h3><p>在<strong>类型2</strong>驱动程序中，JDBC API调用将转换为本地C/C++ API调用，这是数据库唯一的。 这些驱动程序通常由数据库供应商提供，并以与JDBC-ODBC桥接相同的方式使用。 必须在每个客户机上安装供应商特定的驱动程序。</p>
<p>如果要更改数据库，则必须更改原生API，因为它特定于数据库，并且现在大部分已经过时，但是使用<strong>类型2</strong>驱动程序实现了一些扩展功能的开发，它消除了ODBC的开销。</p>
<p><img src="http://www.yiibai.com/uploads/images/201705/3005/881110514_49239.jpg" alt="img"></p>
<p>Oracle调用接口(OCI)驱动程序是<strong>类型2</strong>驱动程序的示例。</p>
<h3 id="类型3：JDBC-Net纯Java"><a href="#类型3：JDBC-Net纯Java" class="headerlink" title="类型3：JDBC-Net纯Java"></a>类型3：JDBC-Net纯Java</h3><p>在<strong>类型3</strong>驱动程序中，使用三层方法访问数据库。 JDBC客户端使用标准网络套接字与中间件应用程序服务器进行通信。 套接字信息随后由中间件应用服务器转换成DBMS所需的调用格式，并转发到数据库服务器。</p>
<p>这种驱动程序是非常灵活的，因为它不需要在客户端上安装代码，<strong>一个驱动程序实际上可以提供多个数据库的访问。</strong></p>
<p><img src="http://www.yiibai.com/uploads/images/201705/3005/700110516_88885.jpg" alt="img"></p>
<p>可以将应用程序服务器视为JDBC“代理”，它会调用客户端应用程序。 因此，我们需要了解应用程序服务器的配置，才能有效地使用此驱动程序类型。</p>
<p>应用程序服务器可能会使用类型1,2或4驱动程序与数据库通信，了解细微差别对理解JDBC是有帮助的。</p>
<h3 id="类型4：100％纯Java"><a href="#类型4：100％纯Java" class="headerlink" title="类型4：100％纯Java"></a>类型4：100％纯Java</h3><p>在<strong>类型4</strong>驱动程序中，基于纯Java的驱动程序通过套接字连接与供应商的数据库直接通信。 这是数据库可用的最高性能驱动程序，通常由供应商自己提供。</p>
<p>这种驱动是非常灵活的，不需要在客户端或服务器上安装特殊的软件。 此外，这些驱动程序可以动态下载。</p>
<p><img src="http://www.yiibai.com/uploads/images/201705/3005/770110529_65984.jpg" alt="img"></p>
<p>MySQL <code>Connector/J</code>驱动程序是<strong>类型4</strong>驱动程序。 由于其网络协议的专有性质，数据库供应商通常提供<strong>类型4</strong>驱动程序。</p>
<h2 id="应该使用哪个驱动程序？"><a href="#应该使用哪个驱动程序？" class="headerlink" title="应该使用哪个驱动程序？"></a>应该使用哪个驱动程序？</h2><p>如果您正在访问一种类型的数据库，例如Oracle，Sybase或IBM DB2，则首选驱动程序类型为<strong>类型4</strong>。</p>
<p>如果Java应用程序同时访问多种类型的数据库，则<strong>类型3</strong>是首选驱动程序。</p>
<p><strong>类型2</strong>驱动程序在数据库不可用的<strong>类型3</strong>或<strong>类型4</strong>驱动程序的情况下使用。</p>
<p><strong>类型1</strong>驱动程序不被视为部署级驱动程序，通常仅用于开发和测试目的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JDBC(七)异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JDBC(七)异常/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDBC最常见的异常是 SQLException</p>
<p>获取错误的信息的一些方法 通过SQLException对象来调用</p>
<table>
<thead>
<tr>
<th><code>getErrorCode( )</code></th>
<th>获取与异常关联的错误代码。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getMessage( )</code></td>
<td>获取驱动程序处理的错误的JDBC驱动程序的错误消息，或获取数据库错误的Oracle错误代码和消息。</td>
</tr>
<tr>
<td><code>getSQLState( )</code></td>
<td>获取XOPEN SQLstate字符串。 对于JDBC驱动程序错误，不会从此方法返回有用的信息。 对于数据库错误，返回五位数的XOPEN SQLstate代码。 此方法可以返回<code>null</code>。</td>
</tr>
<tr>
<td><code>getNextException( )</code></td>
<td>获取异常链中的下一个<code>Exception</code>对象。</td>
</tr>
<tr>
<td><code>printStackTrace( )</code></td>
<td>打印当前异常或可抛出的异常，并将其追溯到标准错误流。</td>
</tr>
<tr>
<td><code>printStackTrace(PrintStream s)</code></td>
<td>将此<code>throwable</code>及其回溯打印到指定的打印流。</td>
</tr>
<tr>
<td><code>printStackTrace(PrintWriter w)</code></td>
<td>打印这个<code>throwable</code>，它是回溯到指定的打印器(<code>PrintWriter</code>)。</td>
</tr>
</tbody>
</table>
<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>一次性向数据库发送多个sql语句可以减少通信花销提高性能</p>
<p>首先得看看jdbc驱动是否支持该功能</p>
<p>使用 <code>DatabaseMetaData.supportsBatchUpdates()</code> 去检查目标数据库和驱动是否支持把？ 如果支持则返回true</p>
<ul>
<li>用Statement和其兄弟的addBatch 将单个语句添加到批处理 executeBatch() 执行批量处理的所有语句</li>
<li>我们可以使用clearBatch()删除等待执行的批量处理的所有语句，不过是全部删除，不能单个删除</li>
</ul>
<p>感觉PreparedStatement和Statement差不多，不过好像没有CallableStatement的用法</p>
<ul>
<li>创建Statement/PreparedStatement 对象</li>
<li>conn.setAutoCommit(false)</li>
<li>addBatch()  将构造好的Statement对象传进去，注意prepareStatement的sql也是填好参数了，Statement就在addBatch参数传入sql语句</li>
<li>executeBatch() 执行所有sql语句</li>
<li>commit 提交事务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假装statement/preparedStatement构造完成</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">stmt.setXXX(...); stmt.addBatch();  /stmt.addBatch(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好像是能返回结果的？ 不过如果太多怎么处理？</span></span><br><span class="line">stmt.executeBatch();</span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure>
<p>JDBC的SQL转义语法</p>
<h2 id="JDBC-SQL转义语法"><a href="#JDBC-SQL转义语法" class="headerlink" title="JDBC SQL转义语法"></a>JDBC SQL转义语法</h2><p>通过使用标准JDBC方法和属性，转义语法使您能够灵活地使用不可用的数据库特定功能。</p>
<p>一般SQL转义语法格式如下 -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;keyword &apos;parameters&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>以下是以下转义序列，在执行JDBC编程时非常有用 -</p>
<p><strong>d, t, ts关键字</strong></p>
<p>它们用于帮助确定日期，时间和时间戳文字。没有哪两个DBMS表示时间和日期的方式相同。 该转义语法告诉驱动程序以目标数据库的格式呈现日期或时间。 例如 -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;d &apos;yyyy-mm-dd&apos;&#125;</span><br></pre></td></tr></table></figure>
<p><code>yyyy</code>=年份，<code>mm</code>=月份; <code>dd</code>=日期。 使用这种语法<code>{d&#39;2019-09-03&#39;}</code>表示的是2019年3月9日。</p>
<p>这是一个简单的示例，显示如何将日期插入表中 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a Statement object</span></span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//Insert data ==&gt; ID, First Name, Last Name, DOB</span></span><br><span class="line">String sql=<span class="string">"INSERT INTO STUDENTS VALUES"</span> +</span><br><span class="line">             <span class="string">"(100,'Kobe','Bryant', &#123;d '2002-12-16'&#125;)"</span>;</span><br><span class="line"></span><br><span class="line">stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java</span><br></pre></td></tr></table></figure>
<p>同样，还可以使用以下两种语法：<code>t</code>或<code>ts</code> -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;t &apos;hh:mm:ss&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>hh</code>=小时，<code>mm</code> =分钟， <code>ss</code> =秒。 使用这种语法<code>{t &#39;13:30:29&#39;}</code>是<code>1:30:29 PM</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;ts &apos;yyyy-mm-dd hh:mm:ss&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>这里“<code>d</code>”和“<code>t</code>”是上述两种语法的组合语法来表示时间戳。</p>
<p><strong>escape关键字</strong></p>
<p><code>escape</code>关键字标识<code>LIKE</code>子句中使用转义字符。 使用SQL通配符<code>%</code>(与<code>0</code>个或多个字符匹配)时很有用。 例如 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT symbol FROM MathSymbols</span></span><br><span class="line"><span class="string">              WHERE symbol LIKE '\%' &#123;escape '\'&#125;"</span>;     <span class="comment">//escape声明 \是转义字符</span></span><br><span class="line">stmt.execute(sql);</span><br></pre></td></tr></table></figure>
<p>如果使用反斜杠字符(<code>\</code>)作为转义字符，则还必须在Java字符串文字中使用<strong>两个反斜杠</strong>字符，因为反斜杠也是Java转义字符。</p>
<p><strong>fn 关键字</strong></p>
<p>这个关键字表示DBMS中使用的标量函数。 例如，可以使用SQL函数长度来获取字符串的长度 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="function">fn <span class="title">length</span><span class="params">(<span class="string">'Hello World'</span>)</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面语句返回结果值为：<code>11</code>，也就是字符串’<code>Hello World</code>‘的长度。</p>
<p><strong>call 关键字</strong></p>
<p>此关键字用于调用存储过程。 例如，对于需要<code>IN</code>参数的存储过程，请使用以下语法 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="function">call <span class="title">my_procedure</span><span class="params">(?)</span>&#125;</span>;</span><br><span class="line">&#123;? = <span class="function">call <span class="title">my_procedure</span><span class="params">(?)</span>&#125;</span>;   <span class="comment">//感觉这个不像是存储过程的啊，像是存储函数的</span></span><br></pre></td></tr></table></figure>
<p>有一个博客是这样调用存储函数的，但是好像没怎么见到是这样调用存储过程的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFuntion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//jdbc调用存储函数sql语句：</span></span><br><span class="line">        <span class="comment">//&#123;?= call &lt;procedure-name&gt;[(&lt;arg1&gt;,&lt;arg2&gt;, ...)]&#125;</span></span><br><span class="line">        String sql = <span class="string">"&#123;? = call queryEmpIncome(?)&#125;"</span>;</span><br><span class="line">        </span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        CallableStatement call = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            call = conn.prepareCall(sql);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注册输出参数</span></span><br><span class="line">            call.registerOutParameter(<span class="number">1</span>, OracleTypes.NUMBER);</span><br><span class="line">            <span class="comment">//输入参数</span></span><br><span class="line">            call.setInt(<span class="number">2</span>, <span class="number">7839</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            call.execute();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//取出返回值</span></span><br><span class="line">            <span class="keyword">double</span> income = call.getDouble(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"年薪："</span>+income);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JDBCUtils.release(conn, call, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也有这样调用</span><br><span class="line"></span><br><span class="line">            String sql = <span class="string">"select fun_avg_dept(?) from dual"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用方式还是和使用ps调用普通SQL一样</span></span><br><span class="line">            PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            ResultSet rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getObject(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p><strong>oj关键字</strong></p>
<p>此关键字用于表示外部连接。 语法如下 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;oj outer-join&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<em>outer-join = table {LEFT|RIGHT|FULL} OUTERJOIN {table | outer-join}</em> 搜索条件。 例如 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT Employees </span></span><br><span class="line"><span class="string">              FROM &#123;oj ThisTable RIGHT</span></span><br><span class="line"><span class="string">              OUTER JOIN ThatTable on id = '100'&#125;"</span>;</span><br><span class="line">stmt.execute(sql);</span><br></pre></td></tr></table></figure>
<p><code>PreparedStatement</code>对象可以使用输入和输出流来提供参数数据。能够将整个文件放入可以容纳大值的数据库列，例如<code>CLOB</code>和<code>BLOB</code>数据类型。</p>
<p>有以下方法可用于流式传输数据 -</p>
<ul>
<li><code>setAsciiStream()</code>：此方法用于提供大的ASCII值。</li>
<li><code>setCharacterStream()</code>：此方法用于提供较大的UNICODE值。</li>
<li><code>setBinaryStream()</code>：此方法用于提供较大的二进制值。</li>
</ul>
<p><code>setXXXStream()</code>方法除了参数占位符之外还需要额外的参数和文件大小。此参数通知驱动程序使用流向数据库发送多少数据。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>考虑要将XML文件<code>xml_data.xml</code>上传到数据库表中。下面是XML文件的内容 -</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>125<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">first</span>&gt;</span>Max<span class="tag">&lt;/<span class="name">first</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">last</span>&gt;</span>Su<span class="tag">&lt;/<span class="name">last</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Salary</span>&gt;</span>18000<span class="tag">&lt;/<span class="name">Salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Dob</span>&gt;</span>18-08-1978<span class="tag">&lt;/<span class="name">Dob</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XML</span><br></pre></td></tr></table></figure>
<p>将此XML文件保存在要运行此示例的同一目录中。</p>
<p>此示例将在数据库创建一个表：<em>xml_data</em>，然后将文件<code>xml_data.xml</code>上传到此表中。</p>
<p>复制以下示例代码，并保存在文件：<em>StreamingData.java</em> 中，编译并运行如下 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import required packages</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingData</span> </span>&#123;</span><br><span class="line">   <span class="comment">// JDBC driver name and database URL</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost/EMP"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  Database credentials</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Connection conn = <span class="keyword">null</span>;</span><br><span class="line">   PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">   Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">   ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// Register JDBC driver</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Open a connection</span></span><br><span class="line">      System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">      conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Create a Statement object and build table</span></span><br><span class="line">      stmt = conn.createStatement();</span><br><span class="line">      createXMLTable(stmt);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Open a FileInputStream</span></span><br><span class="line">      File f = <span class="keyword">new</span> File(<span class="string">"xml_data.xml"</span>);</span><br><span class="line">      <span class="keyword">long</span> fileLength = f.length();</span><br><span class="line">      FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);   <span class="comment">//构造文件流</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//Create PreparedStatement and stream data</span></span><br><span class="line">      String SQL = <span class="string">"INSERT INTO XML_Data VALUES (?,?)"</span>;</span><br><span class="line">      pstmt = conn.prepareStatement(SQL);</span><br><span class="line">      pstmt.setInt(<span class="number">1</span>,<span class="number">125</span>);</span><br><span class="line">      pstmt.setAsciiStream(<span class="number">2</span>,fis,(<span class="keyword">int</span>)fileLength);  <span class="comment">//传递文件流 并且设置文件长度</span></span><br><span class="line">      pstmt.execute();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Close input stream</span></span><br><span class="line">      fis.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do a query to get the row</span></span><br><span class="line">      SQL = <span class="string">"SELECT Data FROM XML_Data WHERE id=125"</span>;</span><br><span class="line">      rs = stmt.executeQuery (SQL);</span><br><span class="line">      <span class="comment">// Get the first row</span></span><br><span class="line">      <span class="keyword">if</span> (rs.next ())&#123;</span><br><span class="line">         </span><br><span class="line">         InputStream xmlInputStream = rs.getAsciiStream (<span class="number">1</span>);   </span><br><span class="line">          <span class="comment">//从resultset得到ascll流后将其转为byte的数组流</span></span><br><span class="line">         <span class="keyword">int</span> c;</span><br><span class="line">         ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         <span class="keyword">while</span> (( c = xmlInputStream.read ()) != -<span class="number">1</span>)</span><br><span class="line">            bos.write(c);</span><br><span class="line">         <span class="comment">//Print results</span></span><br><span class="line">         System.out.println(bos.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Clean-up environment</span></span><br><span class="line">      rs.close();</span><br><span class="line">      stmt.close();</span><br><span class="line">      pstmt.close();</span><br><span class="line">      conn.close();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for JDBC</span></span><br><span class="line">      se.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for Class.forName</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//finally block used to close resources</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">            stmt.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">      &#125;<span class="comment">// nothing we can do</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pstmt!=<span class="keyword">null</span>)</span><br><span class="line">            pstmt.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">      &#125;<span class="comment">// nothing we can do</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">            conn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">         se.printStackTrace();</span><br><span class="line">      &#125;<span class="comment">//end finally try</span></span><br><span class="line">   &#125;<span class="comment">//end try</span></span><br><span class="line">   System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;<span class="comment">//end main</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createXMLTable</span><span class="params">(Statement stmt)</span> </span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"Creating XML_Data table..."</span> );</span><br><span class="line">   <span class="comment">//Create SQL Statement</span></span><br><span class="line">   String streamingDataSql = <span class="string">"CREATE TABLE XML_Data "</span> +</span><br><span class="line">                             <span class="string">"(id INTEGER, Data LONG)"</span>;     <span class="comment">//存储类型是的是Long</span></span><br><span class="line">   <span class="comment">//Drop table first if it exists.</span></span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      stmt.executeUpdate(<span class="string">"DROP TABLE XML_Data"</span>);</span><br><span class="line">   &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">   &#125;<span class="comment">// do nothing</span></span><br><span class="line">   <span class="comment">//Build table.</span></span><br><span class="line">   stmt.executeUpdate(streamingDataSql);</span><br><span class="line">&#125;<span class="comment">//end createXMLTable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JDBC(六)事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JDBC(六)事务/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDBC连接处于自动提交模式，正常的话每个sql完成后都会提交到数据库</p>
<p>但是使用事务的原因</p>
<ul>
<li>提高性能</li>
<li>保持业务流程的完整</li>
<li>使用分布式事务</li>
</ul>
<p>如果不是使用自动提交模式，而是开启手动事务支持 </p>
<p><code>conn.setAutoCommit(false)</code></p>
<p>提交事务，进行更改</p>
<p><code>con.commit()</code></p>
<p>使用conn进行数据库</p>
<p><code>con.rollback()</code></p>
<p>操作流程</p>
<ul>
<li>关闭自动提交，开启事务</li>
<li>创建Statement对象</li>
<li>构造sql语句，并execute</li>
<li>commit 提交事务</li>
<li>出现SQLException 后执行rollback 进行事务回滚</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行事务提交或回滚都是要Connection对象进行操作</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stm=con.createStatement();</span><br><span class="line">    String sql=<span class="string">"select * from test"</span>;</span><br><span class="line">    rs=stmt.executeQuery(sql);</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Savepoint 保存点</p>
<p>这让你在回滚中，可以跑回这个保存点</p>
<p>Connection 采用两个方法去管理保存点</p>
<ul>
<li>setSavepoint(String savepointname)    设置保存点它返回一个savepoint对象</li>
<li>releaseSavepoint(Savepoint savepoint) 删除保存点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stmt=conn.createStatement();</span><br><span class="line">    String sql=<span class="string">"xxx"</span>;</span><br><span class="line">    Savepoint savepoint1=conn.setSavepoint(<span class="string">"xxx"</span>);</span><br><span class="line">    stmt.executeUpdate(sql);</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException s)&#123;</span><br><span class="line">    conn.rollback(savepoint1);        <span class="comment">//传入savepoint作为参数 savepoint对象在try声明的catch依然有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个保存点和回滚的应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STEP 1. Import required packages</span></span><br><span class="line"><span class="comment">// See more detail at http://www.yiibai.com/jdbc/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCSavepoint</span> </span>&#123;</span><br><span class="line">   <span class="comment">// JDBC driver name and database URL</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost/EMP"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  Database credentials</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Connection conn = <span class="keyword">null</span>;</span><br><span class="line">   Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//STEP 2: Register JDBC driver</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 3: Open a connection</span></span><br><span class="line">      System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">      conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 4: Set auto commit as false.</span></span><br><span class="line">      conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 5: Execute a query to delete statment with</span></span><br><span class="line">      <span class="comment">// required arguments for RS example.</span></span><br><span class="line">      System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">      stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 6: Now list all the available records.</span></span><br><span class="line">      String sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">      ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">      System.out.println(<span class="string">"List result set for reference...."</span>);</span><br><span class="line">      printRs(rs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 7: delete rows having ID grater than 104</span></span><br><span class="line">      <span class="comment">// But save point before doing so.</span></span><br><span class="line">      Savepoint savepoint1 = conn.setSavepoint(<span class="string">"ROWS_DELETED_1"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Deleting row...."</span>);</span><br><span class="line">      String SQL = <span class="string">"DELETE FROM Employees "</span> +</span><br><span class="line">                   <span class="string">"WHERE ID = 106"</span>;</span><br><span class="line">      stmt.executeUpdate(SQL);  </span><br><span class="line">      <span class="comment">// oops... we deleted too wrong employees!</span></span><br><span class="line">      <span class="comment">//STEP 8: Rollback the changes afetr save point 2.</span></span><br><span class="line">      conn.rollback(savepoint1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 9: delete rows having ID grater than 104</span></span><br><span class="line">      <span class="comment">// But save point before doing so.</span></span><br><span class="line">      Savepoint savepoint2 = conn.setSavepoint(<span class="string">"ROWS_DELETED_2"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Deleting row...."</span>);</span><br><span class="line">      SQL = <span class="string">"DELETE FROM Employees "</span> +</span><br><span class="line">                   <span class="string">"WHERE ID = 107"</span>;</span><br><span class="line">      stmt.executeUpdate(SQL);  </span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 10: Now list all the available records.</span></span><br><span class="line">      sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">      rs = stmt.executeQuery(sql);</span><br><span class="line">      System.out.println(<span class="string">"List result set for reference...."</span>);</span><br><span class="line">      printRs(rs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 10: Clean-up environment</span></span><br><span class="line">      rs.close();</span><br><span class="line">      stmt.close();</span><br><span class="line">      conn.close();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for JDBC</span></span><br><span class="line">      se.printStackTrace();</span><br><span class="line">      <span class="comment">// If there is an error then rollback the changes.</span></span><br><span class="line">      System.out.println(<span class="string">"Rolling back data here...."</span>);</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">            conn.rollback();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">         se2.printStackTrace();</span><br><span class="line">      &#125;<span class="comment">//end try</span></span><br><span class="line"></span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for Class.forName</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//finally block used to close resources</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">            stmt.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">      &#125;<span class="comment">// nothing we can do</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">            conn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">         se.printStackTrace();</span><br><span class="line">      &#125;<span class="comment">//end finally try</span></span><br><span class="line">   &#125;<span class="comment">//end try</span></span><br><span class="line">   System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;<span class="comment">//end main</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRs</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">      <span class="comment">//Ensure we start with first row</span></span><br><span class="line">      rs.beforeFirst();</span><br><span class="line">      <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">         <span class="comment">//Retrieve by column name</span></span><br><span class="line">         <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">         <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">         String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">         String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//Display values</span></span><br><span class="line">         System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">         System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">         System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">         System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">   &#125;<span class="comment">//end printRs()</span></span><br><span class="line">&#125;<span class="comment">//end JDBCExample</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JDBC(二)应用创建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JDBC(二)应用创建/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来看我们一个基本的JDBC应用的组成</p>
<p>基本的对象</p>
<ul>
<li>Connection  返回数据库连接实体</li>
<li>Statement  返回构造的语句对象</li>
<li>ResultSet  存放数据库返回的结果集</li>
</ul>
<p>所以基本的执行流程是分成三个</p>
<ul>
<li>获得Connection对象</li>
<li>构造并执行Statement</li>
<li>得到并处理ResultSet</li>
</ul>
<hr>
<h3 id="获得Connection对象"><a href="#获得Connection对象" class="headerlink" title="获得Connection对象"></a>获得Connection对象</h3><p>声明：我这里是集成tomcat的应用</p>
<p>获得Connection对象是通过预定义好的资源中获取的所以要通过上下文进行资源选择</p>
<p>数据库连接资源在tomcat中是定义是DataSource，所以记得强制转换一下类型</p>
<p>最后进行getConnection方法返回Connection对象</p>
<p>上面我是放在一个class中自定义的一个静态方法实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> getConn&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> NamingException,SQLException</span>&#123;</span><br><span class="line">        Connection result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取上下文的对象</span></span><br><span class="line">        InitialContext ctx=<span class="keyword">new</span> InitialContext();</span><br><span class="line">        DataSource ds=(DataSource)ctx.lookup(<span class="string">"java:comp/env/jdbc/test"</span>);</span><br><span class="line">        result=ds.getConnection();</span><br><span class="line">        <span class="comment">//System.out.println("xixixi");         这个代码会出现在startup.bat的窗口中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们是用tomcat来处理jdbc的连接问题，所以很多设置已经在context.xml中设置完成 但如果不是用tomcat的java程序使用数据库可能就像这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://hostname:port/db_name"</span>,<span class="string">"db_username"</span>, <span class="string">"db_password"</span>);<span class="comment">//url格式和数据库类型密切相关，这里是mysql的连接</span></span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
<p>传说还有一种方法利用DriverManager去注册类，然后再用getConnection进行url 账号密码等信息传递</p>
<h3 id="构造Statement对象，执行查询"><a href="#构造Statement对象，执行查询" class="headerlink" title="构造Statement对象，执行查询"></a>构造Statement对象，执行查询</h3><p>获得Connection对象后就可以构造Statement了</p>
<p>这里的代码会实现在一个jsp页面中，因此除了需要引入上面的类以外，还要引入 java.sql.*</p>
<p>构造方式很简单</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.sql.*,javaBean.DBUtil"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection con=getConn.getConnection();</span><br><span class="line">Statement stmt=con.createStatement();</span><br><span class="line">ResultSet rs=stmt.executeQuery(<span class="string">"select * from test"</span>);  <span class="comment">//执行语句并返回了</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    out.println(rs.getString(<span class="number">2</span>));    <span class="comment">//打印数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试关闭Statement对象和Connection对象  并防止SQLException错误</span></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/JDBC(三)Statement家族/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/JDBC(三)Statement家族/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Statement家族</p>
<p>其实是祖孙三代 Statement PreparedStatement CallableStatement  其实它们都只是个接口</p>
<ul>
<li>Statement 用于普通的访问啦，就是普通的静态sql语句使用</li>
<li>PreparedStatement  用于计划多次使用sql时，而且是动态sql，可改变参数构造</li>
<li>CallableStatement  也是支持动态sql，不过是专门是用于存储过程的样子</li>
</ul>
<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>构造Statement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stm=conn.createStatement();   <span class="comment">//con是Connection对象</span></span><br></pre></td></tr></table></figure>
<p>Statement的使用</p>
<p>所谓使用只不过将sql语句传递进去，让其执行而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs=stmt.executeQuery(<span class="string">"select * from test"</span>);</span><br><span class="line">rs.getString(<span class="number">1</span>);   <span class="comment">//好像从1开始 参数为序号</span></span><br></pre></td></tr></table></figure>
<p>实际上不只是executeQuery 还有其他执行的方式 </p>
<ul>
<li>boolean execute(String sql) 就执行，如果有ResultSet的存在 则返回true 适合一些不需要返回值的东东，比如创建数据库 创建表这个</li>
<li>int executeUpdate(String sql) 会返回sql影响的数据库行数， 适合一些 insert update delete</li>
</ul>
<p>关闭Statement</p>
<p>Statement和Connection一样都需要关闭，如果关闭Connection 它也会先关闭Statement 但最好显式关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    stmt=conn.createStatement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e)&#123;&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    stmt.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PreparedStatement对象"><a href="#PreparedStatement对象" class="headerlink" title="PreparedStatement对象"></a>PreparedStatement对象</h3><p>PreparedStatement 的String可以构造带参数的sql语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"update aatable set age=? where id=?"</span></span><br><span class="line">PreparedStatement stmt=conn.prepareStatement(sql);        <span class="comment">//构造函数变成preparedStatement对象  构造函数没有d</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>,<span class="number">23</span>);            <span class="comment">//序号从1 开始 不是从0开始</span></span><br><span class="line">stmt.setString(<span class="number">2</span>,<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">int</span> rs=stmt.executeUpdate();</span><br></pre></td></tr></table></figure>
<p>preparedStatement 同样支持 execute() executeQuery()</p>
<p>不过区别是sql语句在preparedStatement 是在创建Statement时填入，而对于Statement是execute执行的时候填入</p>
<p>setXXX 有很多 和下面的getXXX 对应</p>
<p>getXXX 有：</p>
<p>getString、getBigDecimal、getString、getDate、getURL getInt(int parameterIndex)</p>
<p>关闭的方法也一样</p>
<p>CallableStatement</p>
<p>首先定义一个存储过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">create procedure kk(IN id int,OUT meizizi varchar(233))</span><br><span class="line">begin</span><br><span class="line">	select username into meizizi from kk_table where k_id =id;</span><br><span class="line">end//</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"&#123;call kk(?,?)&#125;"</span>;</span><br><span class="line">CallableStatement stmt=conn.prepareCall(sql);   <span class="comment">//是prepareCall 没有d</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>,<span class="number">233</span>);   <span class="comment">//传参了  setXXX</span></span><br><span class="line"><span class="comment">//OUT INOUT 参数时都需要一个额外的registerOutParameter 将参数和类型绑定一下  </span></span><br><span class="line">stmt.registerOutParameter(<span class="number">2</span>,Types.VARCHAR);</span><br><span class="line"><span class="comment">//猜如果时INOUT 参数 可以之后再 setXXX 一下</span></span><br><span class="line">stmt.execute();</span><br><span class="line"><span class="comment">//结果都存在Statement中？</span></span><br><span class="line">String a=stmt.getString(<span class="string">"meizizi"</span>);    <span class="comment">//通过getXXX 加参数名获得OUT/INOUT参数</span></span><br></pre></td></tr></table></figure>
<p>关闭也一样</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/Java网络编程(十三)组播/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/Java网络编程(十三)组播/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h3><p>IP组播是在广播和点对点通信之间 ，他依靠中间爱你网站的复制和中转信息，将信息传送给下游网站（路由器？）</p>
<p>路由器会限制广播会仅限于本地网络或者子网</p>
<p>曾经有种解决方式是 创建静态连接树      数据由起始网站提供给其他服务器，这些服务器再讲将这些数据复制到另外一些路由器，最终复制到客户端。但这种东西比较过时，也因为新网站需要找到一个位置手工加入连接树，而且这个连接树不一定任何时候都是最好的拓扑结构，另外服务器本身需要维护很多指向客户端的点对点连接。所以这是引入组播的理由</p>
<p>组播相比静态连接树，他的智能之处就是，他是将信息比较准确的复制数据发送到一个范围的组播地址，然后这个组播地址再发送给该组的每一个主机。 但其实在Internent上的组播很少用，组播更多是用在某个组织的防火墙内部使用。注意使用这个的时候有一个叫TTL的首部字段，其实是限制数据包转发的次数，从而限制组播的范围。</p>
<p>组播地址是有一个相对比较固定的范围<br>比如IPV4 就是 244.0.0.0 到 239.255.255.255 之间  </p>
<p>组播地址可以有一个主机名，例如 224.0.1.1 就分配有主机名 ntp.mcast.net</p>
<p>除了一些范围内的组播地址块已经为特殊用途所保留，其他剩余的组播地址都可以由任何人有需要时使用。组播路由器负责确保两个不同的系统不会同时使用相同的地址</p>
<p>当一台主机打算向组播组发送数据的时候，它会将数据放在组播数据报中，组播数据报就是发送到组播组的UDP数据报而已。 为什么不用TCP，因为TCP会要求主机确认所有已经接受的报，放在多个主机的组播环境下，效率会低得可怕。<br>如果你的应用程序不允许数据的丢失，那你就要负责确定数据是否损坏而且如何处理，比如你可能需要一个分布式的缓存系统，当数据丢失没可能只用使用之前文件的缓存不做改变</p>
<p>组播和和正常的UDP socket 之间的主要区别是TTL 一般来说</p>
<ul>
<li>本地主机 0</li>
<li>本地子网 1</li>
<li>本地校园网 16</li>
<li>同一个国家的高带宽网站 32</li>
<li>同一个国家所有网站   48</li>
<li>世界内的所有网站 255</li>
</ul>
<p>但如果包是发送到 224.0.0.0 - 224.0.0.255 即 local-link地址 则永远不会发送到本地子网之外</p>
<p>引入组播Socket 导致在任何指定的网段上，相同的数据不会发送多次，实际的路由问题变简化了</p>
<p>组播最大的限制就是是否有特殊的组播路由器或者路由是否启用组播的功能</p>
<p>可以尝试 ping 一下组播地址</p>
<p>ping all-routers.mcast.net 如果有路由器响应，则说明有组播路由器</p>
<p>但即使ping成功也可能无法让你成功组播</p>
<p>组播socket</p>
<p>我们是使用 MulticastSocket 他是DatagramSocket的一个子类</p>
<p>他和DatagramSocket 很像，需要将数据放在DatagramPacket对象中，然后通过MulticastSocket去收发这个DatagramPacket对象</p>
<p><code>MulticastSocket ms=new MulticastSocket(2300);</code> 创建socket，参数代表监听端口。</p>
<p><code>InetAddress group= InetAddress.getByName(&quot;224.2.2.2&quot;);</code><br><code>ms.joinGroup(group);</code><br>将这个socket添加进行组播组</p>
<p>一旦进入组播组，就像一个正常的DatagramSocket就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">DatagramPacket dp=<span class="keyword">new</span> DatagramPacket(buffer,buffer.length);</span><br><span class="line">ms.receive(dp);</span><br></pre></td></tr></table></figure>
<p><code>ms.leaveGroup(group);   ms.close();</code>  离开组播组，然后可以close掉</p>
<p>向组播地址发送数据也一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InetAddress ia=InetAddress.getByName(<span class="string">"experiment.mcast.net"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data=<span class="string">"Here is some cast data \r\n"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">4000</span>;</span><br><span class="line">DatagramPacket dp=<span class="keyword">new</span> DatagramPacket(data,data.length,ia,port);</span><br><span class="line">MultiSocket ms=<span class="keyword">new</span> MultiSocket();</span><br><span class="line">ms.send(dp);</span><br></pre></td></tr></table></figure></p>
<p>组播Socket是一个很大的安全漏洞，所以在SecurityManager控制下运行的不可信代码不允许做任何组播的操作。所以大多数执行远程代码的环境都禁用了组播功能</p>
<p>构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MulticastSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MulticastSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MulticastSocket</span><span class="params">(SocketAddress bindaddr)</span></span></span><br></pre></td></tr></table></figure></p>
<p>能执行一些socket选项的样子 ms.setReuseAddress(false);</p>
<p>一旦创建了MulticastSocket</p>
<ul>
<li>加入组播组</li>
<li>向组中成员发送数据</li>
<li>接收组中的数据</li>
<li>离开组播组</li>
</ul>
<p>必须加入组才能从组接收数据，但向组发送数据并不用先加入组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(InetAddress address)</span>        </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(SocketAddress address,NetworkInterface interface)</span>  <span class="comment">//第二个参数指定网络接口，比如网卡</span></span></span><br></pre></td></tr></table></figure>
<p>试图加入的地址不是组播地址 joinGroup 会抛出IOException</p>
<p>一个MulticastSocket可以加入多个组播组，组播组的成员信息存储在组播路由器中，不在对象中</p>
<p><code>leaveGroup(InetAddress)         leaveGroup(SocketAddress  NetworkInterface)</code>l离开组播组</p>
<p>如果参数不是组播地址 抛出IOException         如果未加入过，则什么都不做</p>
<p>发送组播数据就将 DatagramPacket 包 给MulticastSocket 进行send </p>
<p>注意TTL的情况，默认为 1  可以通过  MulticastSocket 的方法 <code>setTimeToLive()</code>设置默认值，也可以直接进行</p>
<p><code>send(DatagramPacket p,byte ttl)</code>设置ttl,这个优先级比默认的高</p>
<p><code>getTimeToLive()</code>你懂的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    InetAddress ia=InetAddress.getByName(<span class="string">"xxxx.net"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[]data=<span class="string">"This is a test"</span>;</span><br><span class="line">    <span class="keyword">int</span> port=<span class="number">4396</span>;</span><br><span class="line">    DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data,data.length,ia,port);</span><br><span class="line">    MulticastSocket ms=<span class="keyword">new</span> MulticastSocket()</span><br><span class="line">     <span class="comment">//MulticastSocket 可以不加入组就能向该组发送组播数据</span></span><br><span class="line">    ms.setTimeToLive(<span class="number">64</span>);</span><br><span class="line">    ms.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回送模式</p>
<p>你发出去的组播包，是否希望发回来，这个其实取决于平台支不支持，但你可以表达你自己的意愿</p>
<p><code>set/getLoopbackMode(boolean disabled)</code> true表示不希望获得自己发送的包,但不要保证一定如你所愿。你自己应该要做准备</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/Java网络编程(十一)非阻塞IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/Java网络编程(十一)非阻塞IO/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-22T17:36:06+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NIO用于维护超大量长连接，客户端不会频繁发送数据。这时候用NIO会比多线程好。</p>
<p>之前有Java NIO的笔记了，可以回看哦，有些细节在那里有就8讲了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">chargenClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Default_Port=<span class="number">19</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			SocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="string">"rama.poly.edu"</span>, <span class="number">19</span>);</span><br><span class="line">			SocketChannel client=SocketChannel.open(address);</span><br><span class="line">			ByteBuffer buffer=ByteBuffer.allocate(<span class="number">74</span>);</span><br><span class="line">			System.out.println(<span class="string">"connect"</span>);</span><br><span class="line">			<span class="comment">//将System.out也包装成channel</span></span><br><span class="line">			WritableByteChannel out=Channels.newChannel(System.out);</span><br><span class="line">			<span class="keyword">while</span>(client.read(buffer)!=-<span class="number">1</span>) &#123;</span><br><span class="line">				buffer.flip();</span><br><span class="line">				out.write(buffer);</span><br><span class="line">				buffer.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接从InetAddress打开SocketChannel</li>
<li>创建缓存区并立即从SocketChannel读取数据到缓存区</li>
<li>将System.out也包装成Channel,将缓存数据写入Channel中，over</li>
</ul>
<p>read其实是阻塞的一个方法，但是如果你对SocketChannel</p>
<p><code>client.configureBlocking(false)</code> 开启非阻塞模式，read会在没有读取什么数据也返回0 因此此时做循环有区别了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n=client.read(buffer);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        out.write(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//服务器崩了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上我们看到客户端用通道和缓存区好像没啥用，感觉这个对服务器才有点作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverChannel =ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个通道未监听端口，所以要绑定，这个端口通过InetSocketAddress传递</span></span><br><span class="line">ServerSocket ss=serverChannel.socket();</span><br><span class="line">ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">19</span>));</span><br><span class="line"><span class="comment">//或者 serverChannel.bind(new InetSocketAddress(19))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听  返回一个通道 叫客户端通道</span></span><br><span class="line">SocketChannel clientChannel=serverChannel.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//你会希望这个返回的通道是非阻塞的，因为这样允许服务器处理多个并发连接</span></span><br><span class="line">clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServerSocketChannel设置为非阻塞模式，这个accept方法就不会阻塞了</span></span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Selector</span></span><br><span class="line">Selector selector=Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让通道进行注册，然后就能让选择器进行监听</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器通道监听 OP_ACCEPT事件代表该通道准备好接受一个新连接</span></span><br><span class="line">serverChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端也要进行监听注册</span></span><br><span class="line">SelectionKey key=clientChannel.register(selector,SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后安排监听器的事情</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    <span class="comment">//xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听到事件，找到就绪通道后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt;readyKeys=selector.selectedKeys();</span><br><span class="line">Iterator iterator=readyKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    SelectionKey key=iterator.next();</span><br><span class="line">    <span class="keyword">try</span>&#123;   <span class="comment">//可能抛出IOException异常</span></span><br><span class="line">        <span class="comment">//通过事件判断是服务器通道</span></span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">            ServerSocketChannel server=(ServerSocketChannel)key.channel();</span><br><span class="line">            <span class="comment">//得到一个新的客户端通道</span></span><br><span class="line">            SocketChannel connection=server.accept();</span><br><span class="line">            <span class="comment">//异步处理并交给selector</span></span><br><span class="line">            connection.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            connection.register(selector,SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWriteable())&#123;</span><br><span class="line">            SocketChannel client=(SocketChannel)key.channel();</span><br><span class="line">            <span class="comment">//数据写入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除该键，代表已处理</span></span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个新发现的点</p>
<ul>
<li>ServerSocketChannel 也能交个selector上管理 并且知道OP_ACCEPT是用在服务器SocketChannel的</li>
<li>SelectionKey的迭代对象中的channel方法可获得channel不过要强制转换类型一下</li>
<li>通过判断事件可以区分两个不同的通道</li>
<li>实在不行其实可以用两个selector进行区分</li>
</ul>
<p>还有key本身是可以加上一个附件 attachment 这个附件一般是缓冲区ByteBuffer</p>
<p>rewind  把position设为0，limit不变，<strong>一般在把数据重写入Buffer前调用 </strong> 结果却可以调用一些get方法</p>
<p>有了NIO不代表不需要线程，多线程肯定牛啤酒啦，8过，有了NIO的存在，意味着线程和连接就不用1：1了</p>
<p>缓冲区中有个很特别的东西</p>
<p><code>buffer.array()</code>这个是将缓冲区以数组形式返回，这个数组和缓冲区是关联的，修改他们会影响另一个</p>
<p><code>ByteBuffer.allocateDirect(100)</code> 这种好像是VM在系统的缓冲区上直接使用内存访问，以实现ByteBuffer的分配，不搞花里胡哨的后备数组</p>
<p>但此时不能直接用array 和 arrayOffset 会出错，直接缓冲区速度更快，对缓冲区很大时更好，但创建它的代价很高，所以只持续时间比较短的时候用。其细节非常依赖VM 所以不要随便弄</p>
<p>包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data=<span class="string">"Some data"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuffer buffer1=ByteBuffer.wrap(data);</span><br><span class="line"><span class="keyword">char</span>[] text=<span class="string">"Some text"</span>.toCharArray();</span><br><span class="line">CharBuffer buffer2=CharBuffer.wrap(text);</span><br></pre></td></tr></table></figure>
<p>将一个数组直接包装在缓存里面。，其实就是将其作为它的后备数组，这意味着包装创建的缓冲区不是直接缓存区。</p>
<p>而且意味着缓冲区和数组的数据会相互影响</p>
<p>buffer.get() 获取该缓存区的元素，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    result+=buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有 buffer.get(int index) 绝对位置的获取   同理有 put(int index,byte b)</p>
<p>另外绝对位置不会改变position位置</p>
<p>另外还有批量处理</p>
<p>get(byte[] ds,int offset,int length)</p>
<p>get(byte[] ds)</p>
<p>put(byte[] array, int offset, int length)</p>
<p>put(byte[] array)</p>
<p>数据转换  就是ByteBuffer可以弄成其他数据类型</p>
<p>getChar() /getChar(int index,char value)  getChar(int index)/putChar(int index,char value)</p>
<p>同理还有short int long float double</p>
<p>  Buffer可以将字节序列解释为big-endain 或 little-endian 的  int float double 默认是big-endian 可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(buffer.order().equals(ByteOrder.BIG_ENDIAN))&#123;</span><br><span class="line">    buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如用二进制数据测试网络</p>
<p>可能会暴露出一些问题 </p>
<ul>
<li>老的网关配置会出去每个字节的高位 2^30字节就丢一个字节  或因为预料之外的控制字符进行诊断模式</li>
</ul>
<p>视图缓冲区</p>
<p>虽然Socket连接中你只能用ByteBuffer 但其实你可以以int double等这种更高级的数据类型去看待读写，但这就需要将ByteBuffer进行包装，变成视图缓冲区。注意试图缓冲区和底层缓冲区的影响是共享的。不过他们的位置和限度是相互独立的。</p>
<p>还要注意在非阻塞工作的时候，读写上层视图缓存区，要将ByteBuffer中数据排空，非阻塞模式不能保证缓存区在排空后仍以int、double\char类型边界对齐，可能到最后只写入一个字节什么的那就坑爹了。</p>
<p>ShortBuffer asShortBuffer()  这样就让ByteBuffer视图包装成一个ShortByte</p>
<p>其他的还有char int long float double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">intgenClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">1918</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			SocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, DEFAULT_PORT);</span><br><span class="line">			SocketChannel client=SocketChannel.open(address);</span><br><span class="line">			ByteBuffer buffer=ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">			IntBuffer view=buffer.asIntBuffer();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> expected=<span class="number">0</span>;;expected++) &#123;</span><br><span class="line">				client.read(buffer);    <span class="comment">//通道读取到ByteBuffer里</span></span><br><span class="line">				<span class="keyword">int</span> actual=view.get();   <span class="comment">//然后通过视图去获得一整个int  直接通过byteBuffer 去get没有用，因为取一个字节没用，</span></span><br><span class="line">				buffer.clear();</span><br><span class="line">				view.rewind();   <span class="comment">//准备再被read</span></span><br><span class="line">				<span class="keyword">if</span>(actual!=expected) &#123;</span><br><span class="line">					System.err.println(<span class="string">"Expected "</span>+expected+<span class="string">"; was "</span>+actual);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(actual);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子说明视图缓冲区还是很重要的，因为我们知道SocketChannel中的传输都是用ByteBuffer，而有时候我们需要把这些字节解释为Int 这就需要其他的视图缓冲区的帮助</p>
<p>虽然可以用视图缓冲区进行读入和排空，但是呢 SocketChannel这个傲娇的家伙只允许和ByteBuffer进行交流</p>
<p>压缩缓冲区</p>
<p>缓冲有一个 compact方法 ，和clean有点像， 就是将读过的数据清除，然后将还没读取的数据搬到缓冲区前面</p>
<p>对于非阻塞IO进行复制时（读取一个通道，然后将数据写入另一个通道中），压缩是一个特别有用的操作。</p>
<p>这样可以读一部分，写一部分，压缩数据。这样一次IO过程就能完成几次随机的交替的读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key.isWritable()) &#123;</span><br><span class="line">	SocketChannel client=(SocketChannel)key.channel();</span><br><span class="line">	ByteBuffer buffer=(ByteBuffer)key.attachment();</span><br><span class="line">	buffer.flip();</span><br><span class="line">	client.write(buffer);</span><br><span class="line">	buffer.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种只能解决写的部分，但是读的好像并没有类似的操作。</p>
<p>复制缓冲区</p>
<p>如果需要将缓冲区一个相同的信息分发到多个通道，这就需要建立缓冲区的副本，</p>
<p>duplicate() </p>
<p>复制的缓冲区共享相同数据，都是共享影响的。但是初始和缓冲区都有独立的标记、限度和位置。这允许每个通道按照自己的速度读取缓冲区什么的，就很好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">    					SocketChannel client=(SocketChannel)key.channel();</span><br><span class="line">					ByteBuffer buffer=ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						client.read(buffer);   </span><br><span class="line">                        <span class="comment">//这里其实是应该读取客户端到底发了什么再做响应，但这里就忽略了，发送一样的响应</span></span><br><span class="line">						key.interestOps(SelectionKey.OP_WRITE);      <span class="comment">//这个很有趣更改监听的事件</span></span><br><span class="line">						key.attach(contentBuffer.duplicate());          </span><br><span class="line">                        <span class="comment">//这里将成员变量contentBuffer进行复制</span></span><br><span class="line">					&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的重点就是对数据成员对象contentBuffer的复制，这样多个socket都能共享同一个缓冲区，然后<code>key.interestOps(SelectionKey.OP_WRITE)</code>这个改变了监听事件挺有趣的</p>
<p>ServerSocketChannel可以在非阻塞模式 <code>configureBlocking(false)</code>工作，这样accept不会阻塞，可能返回null，这适合需要为每个连接完成大量工作的服务器。</p>
<p>accept方法出错会返回IOException 其实还有几个子类可以指出更详细的问题</p>
<p>ClosedChannelException </p>
<p>AsynchronousCloseException </p>
<p>ClosedByInterruptException </p>
<p>NotYetBoundException </p>
<p>SecurityException</p>
<p>Java7 引入AsynchronousSocketChannel 和 AsynchronousServerSocketChannel类 和SocketChannel 和 ServerSocketChannel很像     但不是子类</p>
<p>特别的是他们干什么本身就是异步的  甚至在IO完成前就返回。 读/写数据会由一个Future或CompletionHandler进一步处理。connect() 和accept()方法都会异步执行，并且返回Future ，这里就不需要用Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress adress=<span class="keyword">new</span> InetSocketAddress(args[<span class="number">0</span>],port);</span><br><span class="line"><span class="comment">//创建一个AsynchronousSocketChannel</span></span><br><span class="line">AsynchronousSocketChannel client=AsynchronousSocketChannel.open();</span><br><span class="line"><span class="comment">//然后连接返回一个connect对象，代表连接</span></span><br><span class="line">Future&lt;Void&gt; connected=client.connect(address);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer=ByteBuffer.allocate(<span class="number">74</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待连接完成</span></span><br><span class="line">connected.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接读取</span></span><br><span class="line">Future&lt;Integer&gt;future=client.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//..做别的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待读取完成</span></span><br><span class="line">future.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//回绕并排空缓冲区</span></span><br><span class="line">buffer.flip();</span><br><span class="line">WritableByteChannel out=Channels.newChannel(System.out);</span><br><span class="line">out.write(buffer);</span><br></pre></td></tr></table></figure>
<p>这种方法可以用于有顺序的获取结果，如果你不关心顺序，可以用CompletionHandler</p>
<p>这个接口声明两个接口 completed() failed()   代表完成调用或者出现IO错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">ByteBuffer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result,ByteBuffer buffer)</span></span>&#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        WritableByteChannel out=Channels.newChanel(System.out);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            out.write(buffer);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123; System.err.println(ex);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable ex,ByteBuffer attachment)</span></span>&#123;</span><br><span class="line">        System.err.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer=ByteBuffer.allocate(<span class="number">74</span>);</span><br><span class="line">CompletionHandler&lt;Integer,ByteBuffer&gt;handler=<span class="keyword">new</span> LineHandler();</span><br><span class="line">channel.read(buffer,buffer,handler);</span><br></pre></td></tr></table></figure>
<p>读取通道，要向read传入一个缓冲区，一个附件和一个CompletionHandler，这里将buffer也作为附件。</p>
<p>另一个常用的模式是将CompletionHandler作为匿名内部类，缓冲区作为作为一个最终局部变量，将缓冲区放入处理器的作用域当中。</p>
<p>尽管可以多线程共享一个AsynochronousSocketChannel 或者 xxServerSocketChannel 但是一次只有一个线程可以读取/写入这个通道。（但是可以一个线程读一个线程写）</p>
<p>Socket选项</p>
<p>Channel们都实现了NetworkChannel接口用支持TCP选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getOption(SocketOption&lt;T&gt;name)</span><br><span class="line">setOption(SocketOption&lt;T&gt;name,T value)</span><br><span class="line">supportedOptions()</span><br></pre></td></tr></table></figure>
<p>这个SocketOption 是一些常量 StandardSocketOptions</p>
<ul>
<li>IP_MULTICAST_IF</li>
<li>IP_MULTICAST_LOOP</li>
<li>IP_TOS</li>
<li>xxxx</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NetworkChannel channel=SocketChannel.open();</span><br><span class="line">channel.setOption(StandardSocketOptions.SO_LINGER,<span class="number">240</span>);</span><br></pre></td></tr></table></figure>
<p>很奇怪虽然supportedOptions 中是有 IP_TOS 而且在StandradSocketOptions 中有设置，但好像并不能 getOptions这个东西，即使设置过了</p>
<p>注意</p>
<ul>
<li>不是所有通道都允许给selector管理的，比如fileChannel 但是网络通信的channel都行</li>
<li>select(long timeout) 超时设置</li>
<li>selector.close() 会释放所有键和所有被select阻塞的线程都会通畅</li>
<li>SelectionKey 的cancel方法 用来撤销注册</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen JianLun</p>
              <p class="site-description motion-element" itemprop="description">Embrace the trend</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen JianLun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
