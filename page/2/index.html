<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Embrace the trend">
<meta property="og:type" content="website">
<meta property="og:title" content="Shaclow&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Shaclow&#39;s Blog">
<meta property="og:description" content="Embrace the trend">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shaclow&#39;s Blog">
<meta name="twitter:description" content="Embrace the trend">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Shaclow's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shaclow's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,my world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/JDBC(五)数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/JDBC(五)数据类型/" itemprop="url">JDBC(五)数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th>SQL类型</th>
<th>JDBC/Java类型</th>
<th>setXXX</th>
<th>updateXXX</th>
</tr>
</thead>
<tbody>
<tr>
<td>VARCHAR</td>
<td>java.lang.String</td>
<td>setString</td>
<td>getString</td>
</tr>
<tr>
<td>CHAR</td>
<td>java.lang.String</td>
<td>setString</td>
<td>getString</td>
</tr>
<tr>
<td>LONGVARCHAR</td>
<td>java.lang.String</td>
<td>setString</td>
<td>getString</td>
</tr>
<tr>
<td>BIT</td>
<td>boolean</td>
<td>setBoolean</td>
<td>getBoolean</td>
</tr>
<tr>
<td>NUMERIC</td>
<td>java.math.BigDecimal</td>
<td>setBigDecimal</td>
<td>getBigDecimal</td>
</tr>
<tr>
<td>TINYINT</td>
<td>byte</td>
<td>setByte</td>
<td>getByte</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>short</td>
<td>setShort</td>
<td>getShort</td>
</tr>
<tr>
<td>INTEGER</td>
<td>int</td>
<td>setInt</td>
<td>getInt</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>setLong</td>
<td>getLong</td>
</tr>
<tr>
<td>REAL</td>
<td>float</td>
<td>setFloat</td>
<td>getFloat</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>setFloat</td>
<td>getFloat</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>setDouble</td>
<td>getDouble</td>
</tr>
<tr>
<td>VARBINARY</td>
<td>byte[ ]</td>
<td>setBytes</td>
<td>getBytes</td>
</tr>
<tr>
<td>BINARY</td>
<td>byte[ ]</td>
<td>setBytes</td>
<td>getBytes</td>
</tr>
<tr>
<td>DATE</td>
<td>java.sql.Date</td>
<td>setDate</td>
<td>getDate</td>
</tr>
<tr>
<td>TIME</td>
<td>java.sql.Time</td>
<td>setTime</td>
<td>getTime</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>java.sql.Timestamp</td>
<td>setTimestamp</td>
<td>getTimestamp</td>
</tr>
<tr>
<td>CLOB</td>
<td>java.sql.Clob</td>
<td>setClob</td>
<td>getClob</td>
</tr>
<tr>
<td>BLOB</td>
<td>java.sql.Blob</td>
<td>setBlob</td>
<td>getBlob</td>
</tr>
<tr>
<td>ARRAY</td>
<td>java.sql.Array</td>
<td>setARRAY</td>
<td>getARRAY</td>
</tr>
<tr>
<td>REF</td>
<td>java.sql.Ref</td>
<td>SetRef</td>
<td>getRef</td>
</tr>
<tr>
<td>STRUCT</td>
<td>java.sql.Struct</td>
<td>SetStruct</td>
<td>getStruct</td>
</tr>
</tbody>
</table>
<p>但即使这样好像也能强制转换为 String那种</p>
<h2 id="处理NULL值"><a href="#处理NULL值" class="headerlink" title="处理NULL值"></a>处理NULL值</h2><p>SQL使用<code>NULL</code>值和Java使用<code>null</code>是不同的概念。 所以，要在Java中处理SQL <code>NULL</code>值，可以使用三种策略 -</p>
<ul>
<li>避免使用返回原始数据类型的<code>getXXX()</code>方法。</li>
<li>对原始数据类型使用包装类，并使用<code>ResultSet</code>对象的<code>wasNull()</code>方法来测试接收<code>getXXX()</code>方法的返回值的包装器类变量是否应设置为<code>null</code>。</li>
<li>使用原始数据类型和<code>ResultSet</code>对象的<code>wasNull()</code>方法来测试接收到由<code>getXXX()</code>方法返回的值的原始变量是否应设置为表示<code>NULL</code>的可接受值。</li>
</ul>
<p>下面是一个用来处理<code>NULL</code>值的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">String sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>( rs.wasNull( ) ) &#123;</span><br><span class="line">   id = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/JDBC(三)Statement家族/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/JDBC(三)Statement家族/" itemprop="url">JDBC(三)Statement家族</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Statement家族</p>
<p>其实是祖孙三代 Statement PreparedStatement CallableStatement  其实它们都只是个接口</p>
<ul>
<li>Statement 用于普通的访问啦，就是普通的静态sql语句使用</li>
<li>PreparedStatement  用于计划多次使用sql时，而且是动态sql，可改变参数构造</li>
<li>CallableStatement  也是支持动态sql，不过是专门是用于存储过程的样子</li>
</ul>
<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>构造Statement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stm=conn.createStatement();   <span class="comment">//con是Connection对象</span></span><br></pre></td></tr></table></figure>
<p>Statement的使用</p>
<p>所谓使用只不过将sql语句传递进去，让其执行而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs=stmt.executeQuery(<span class="string">"select * from test"</span>);</span><br><span class="line">rs.getString(<span class="number">1</span>);   <span class="comment">//好像从1开始 参数为序号</span></span><br></pre></td></tr></table></figure>
<p>实际上不只是executeQuery 还有其他执行的方式 </p>
<ul>
<li>boolean execute(String sql) 就执行，如果有ResultSet的存在 则返回true 适合一些不需要返回值的东东，比如创建数据库 创建表这个</li>
<li>int executeUpdate(String sql) 会返回sql影响的数据库行数， 适合一些 insert update delete</li>
</ul>
<p>关闭Statement</p>
<p>Statement和Connection一样都需要关闭，如果关闭Connection 它也会先关闭Statement 但最好显式关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    stmt=conn.createStatement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException e)&#123;&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    stmt.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PreparedStatement对象"><a href="#PreparedStatement对象" class="headerlink" title="PreparedStatement对象"></a>PreparedStatement对象</h3><p>PreparedStatement 的String可以构造带参数的sql语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"update aatable set age=? where id=?"</span></span><br><span class="line">PreparedStatement stmt=conn.prepareStatement(sql);        <span class="comment">//构造函数变成preparedStatement对象  构造函数没有d</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>,<span class="number">23</span>);            <span class="comment">//序号从1 开始 不是从0开始</span></span><br><span class="line">stmt.setString(<span class="number">2</span>,<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">int</span> rs=stmt.executeUpdate();</span><br></pre></td></tr></table></figure>
<p>preparedStatement 同样支持 execute() executeQuery()</p>
<p>不过区别是sql语句在preparedStatement 是在创建Statement时填入，而对于Statement是execute执行的时候填入</p>
<p>setXXX 有很多 和下面的getXXX 对应</p>
<p>getXXX 有：</p>
<p>getString、getBigDecimal、getString、getDate、getURL getInt(int parameterIndex)</p>
<p>关闭的方法也一样</p>
<p>CallableStatement</p>
<p>首先定义一个存储过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">create procedure kk(IN id int,OUT meizizi varchar(233))</span><br><span class="line">begin</span><br><span class="line">	select username into meizizi from kk_table where k_id =id;</span><br><span class="line">end//</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"&#123;call kk(?,?)&#125;"</span>;</span><br><span class="line">CallableStatement stmt=conn.prepareCall(sql);   <span class="comment">//是prepareCall 没有d</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>,<span class="number">233</span>);   <span class="comment">//传参了  setXXX</span></span><br><span class="line"><span class="comment">//OUT INOUT 参数时都需要一个额外的registerOutParameter 将参数和类型绑定一下  </span></span><br><span class="line">stmt.registerOutParameter(<span class="number">2</span>,Types.VARCHAR);</span><br><span class="line"><span class="comment">//猜如果时INOUT 参数 可以之后再 setXXX 一下</span></span><br><span class="line">stmt.execute();</span><br><span class="line"><span class="comment">//结果都存在Statement中？</span></span><br><span class="line">String a=stmt.getString(<span class="string">"meizizi"</span>);    <span class="comment">//通过getXXX 加参数名获得OUT/INOUT参数</span></span><br></pre></td></tr></table></figure>
<p>关闭也一样</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/JDBC(六)事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/JDBC(六)事务/" itemprop="url">JDBC(六)事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDBC连接处于自动提交模式，正常的话每个sql完成后都会提交到数据库</p>
<p>但是使用事务的原因</p>
<ul>
<li>提高性能</li>
<li>保持业务流程的完整</li>
<li>使用分布式事务</li>
</ul>
<p>如果不是使用自动提交模式，而是开启手动事务支持 </p>
<p><code>conn.setAutoCommit(false)</code></p>
<p>提交事务，进行更改</p>
<p><code>con.commit()</code></p>
<p>使用conn进行数据库</p>
<p><code>con.rollback()</code></p>
<p>操作流程</p>
<ul>
<li>关闭自动提交，开启事务</li>
<li>创建Statement对象</li>
<li>构造sql语句，并execute</li>
<li>commit 提交事务</li>
<li>出现SQLException 后执行rollback 进行事务回滚</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行事务提交或回滚都是要Connection对象进行操作</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stm=con.createStatement();</span><br><span class="line">    String sql=<span class="string">"select * from test"</span>;</span><br><span class="line">    rs=stmt.executeQuery(sql);</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Savepoint 保存点</p>
<p>这让你在回滚中，可以跑回这个保存点</p>
<p>Connection 采用两个方法去管理保存点</p>
<ul>
<li>setSavepoint(String savepointname)    设置保存点它返回一个savepoint对象</li>
<li>releaseSavepoint(Savepoint savepoint) 删除保存点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    Statement stmt=conn.createStatement();</span><br><span class="line">    String sql=<span class="string">"xxx"</span>;</span><br><span class="line">    Savepoint savepoint1=conn.setSavepoint(<span class="string">"xxx"</span>);</span><br><span class="line">    stmt.executeUpdate(sql);</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException s)&#123;</span><br><span class="line">    conn.rollback(savepoint1);        <span class="comment">//传入savepoint作为参数 savepoint对象在try声明的catch依然有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个保存点和回滚的应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STEP 1. Import required packages</span></span><br><span class="line"><span class="comment">// See more detail at http://www.yiibai.com/jdbc/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCSavepoint</span> </span>&#123;</span><br><span class="line">   <span class="comment">// JDBC driver name and database URL</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost/EMP"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  Database credentials</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Connection conn = <span class="keyword">null</span>;</span><br><span class="line">   Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//STEP 2: Register JDBC driver</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 3: Open a connection</span></span><br><span class="line">      System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">      conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 4: Set auto commit as false.</span></span><br><span class="line">      conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 5: Execute a query to delete statment with</span></span><br><span class="line">      <span class="comment">// required arguments for RS example.</span></span><br><span class="line">      System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">      stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 6: Now list all the available records.</span></span><br><span class="line">      String sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">      ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">      System.out.println(<span class="string">"List result set for reference...."</span>);</span><br><span class="line">      printRs(rs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 7: delete rows having ID grater than 104</span></span><br><span class="line">      <span class="comment">// But save point before doing so.</span></span><br><span class="line">      Savepoint savepoint1 = conn.setSavepoint(<span class="string">"ROWS_DELETED_1"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Deleting row...."</span>);</span><br><span class="line">      String SQL = <span class="string">"DELETE FROM Employees "</span> +</span><br><span class="line">                   <span class="string">"WHERE ID = 106"</span>;</span><br><span class="line">      stmt.executeUpdate(SQL);  </span><br><span class="line">      <span class="comment">// oops... we deleted too wrong employees!</span></span><br><span class="line">      <span class="comment">//STEP 8: Rollback the changes afetr save point 2.</span></span><br><span class="line">      conn.rollback(savepoint1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 9: delete rows having ID grater than 104</span></span><br><span class="line">      <span class="comment">// But save point before doing so.</span></span><br><span class="line">      Savepoint savepoint2 = conn.setSavepoint(<span class="string">"ROWS_DELETED_2"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Deleting row...."</span>);</span><br><span class="line">      SQL = <span class="string">"DELETE FROM Employees "</span> +</span><br><span class="line">                   <span class="string">"WHERE ID = 107"</span>;</span><br><span class="line">      stmt.executeUpdate(SQL);  </span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 10: Now list all the available records.</span></span><br><span class="line">      sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">      rs = stmt.executeQuery(sql);</span><br><span class="line">      System.out.println(<span class="string">"List result set for reference...."</span>);</span><br><span class="line">      printRs(rs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 10: Clean-up environment</span></span><br><span class="line">      rs.close();</span><br><span class="line">      stmt.close();</span><br><span class="line">      conn.close();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for JDBC</span></span><br><span class="line">      se.printStackTrace();</span><br><span class="line">      <span class="comment">// If there is an error then rollback the changes.</span></span><br><span class="line">      System.out.println(<span class="string">"Rolling back data here...."</span>);</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">            conn.rollback();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">         se2.printStackTrace();</span><br><span class="line">      &#125;<span class="comment">//end try</span></span><br><span class="line"></span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for Class.forName</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//finally block used to close resources</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">            stmt.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">      &#125;<span class="comment">// nothing we can do</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">            conn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">         se.printStackTrace();</span><br><span class="line">      &#125;<span class="comment">//end finally try</span></span><br><span class="line">   &#125;<span class="comment">//end try</span></span><br><span class="line">   System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;<span class="comment">//end main</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRs</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">      <span class="comment">//Ensure we start with first row</span></span><br><span class="line">      rs.beforeFirst();</span><br><span class="line">      <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">         <span class="comment">//Retrieve by column name</span></span><br><span class="line">         <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">         <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">         String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">         String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//Display values</span></span><br><span class="line">         System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">         System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">         System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">         System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println();</span><br><span class="line">   &#125;<span class="comment">//end printRs()</span></span><br><span class="line">&#125;<span class="comment">//end JDBCExample</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/JDBC(二)应用创建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/JDBC(二)应用创建/" itemprop="url">JDBC(二)应用创建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来看我们一个基本的JDBC应用的组成</p>
<p>基本的对象</p>
<ul>
<li>Connection  返回数据库连接实体</li>
<li>Statement  返回构造的语句对象</li>
<li>ResultSet  存放数据库返回的结果集</li>
</ul>
<p>所以基本的执行流程是分成三个</p>
<ul>
<li>获得Connection对象</li>
<li>构造并执行Statement</li>
<li>得到并处理ResultSet</li>
</ul>
<hr>
<h3 id="获得Connection对象"><a href="#获得Connection对象" class="headerlink" title="获得Connection对象"></a>获得Connection对象</h3><p>声明：我这里是集成tomcat的应用</p>
<p>获得Connection对象是通过预定义好的资源中获取的所以要通过上下文进行资源选择</p>
<p>数据库连接资源在tomcat中是定义是DataSource，所以记得强制转换一下类型</p>
<p>最后进行getConnection方法返回Connection对象</p>
<p>上面我是放在一个class中自定义的一个静态方法实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> getConn&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> NamingException,SQLException</span>&#123;</span><br><span class="line">        Connection result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取上下文的对象</span></span><br><span class="line">        InitialContext ctx=<span class="keyword">new</span> InitialContext();</span><br><span class="line">        DataSource ds=(DataSource)ctx.lookup(<span class="string">"java:comp/env/jdbc/test"</span>);</span><br><span class="line">        result=ds.getConnection();</span><br><span class="line">        <span class="comment">//System.out.println("xixixi");         这个代码会出现在startup.bat的窗口中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们是用tomcat来处理jdbc的连接问题，所以很多设置已经在context.xml中设置完成 但如果不是用tomcat的java程序使用数据库可能就像这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://hostname:port/db_name"</span>,<span class="string">"db_username"</span>, <span class="string">"db_password"</span>);<span class="comment">//url格式和数据库类型密切相关，这里是mysql的连接</span></span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
<p>传说还有一种方法利用DriverManager去注册类，然后再用getConnection进行url 账号密码等信息传递</p>
<h3 id="构造Statement对象，执行查询"><a href="#构造Statement对象，执行查询" class="headerlink" title="构造Statement对象，执行查询"></a>构造Statement对象，执行查询</h3><p>获得Connection对象后就可以构造Statement了</p>
<p>这里的代码会实现在一个jsp页面中，因此除了需要引入上面的类以外，还要引入 java.sql.*</p>
<p>构造方式很简单</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.sql.*,javaBean.DBUtil"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection con=getConn.getConnection();</span><br><span class="line">Statement stmt=con.createStatement();</span><br><span class="line">ResultSet rs=stmt.executeQuery(<span class="string">"select * from test"</span>);  <span class="comment">//执行语句并返回了</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    out.println(rs.getString(<span class="number">2</span>));    <span class="comment">//打印数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试关闭Statement对象和Connection对象  并防止SQLException错误</span></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Java网络编程(十一)非阻塞IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Java网络编程(十一)非阻塞IO/" itemprop="url">Java网络编程(十一)非阻塞IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NIO用于维护超大量长连接，客户端不会频繁发送数据。这时候用NIO会比多线程好。</p>
<p>之前有Java NIO的笔记了，可以回看哦，有些细节在那里有就8讲了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">chargenClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Default_Port=<span class="number">19</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			SocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="string">"rama.poly.edu"</span>, <span class="number">19</span>);</span><br><span class="line">			SocketChannel client=SocketChannel.open(address);</span><br><span class="line">			ByteBuffer buffer=ByteBuffer.allocate(<span class="number">74</span>);</span><br><span class="line">			System.out.println(<span class="string">"connect"</span>);</span><br><span class="line">			<span class="comment">//将System.out也包装成channel</span></span><br><span class="line">			WritableByteChannel out=Channels.newChannel(System.out);</span><br><span class="line">			<span class="keyword">while</span>(client.read(buffer)!=-<span class="number">1</span>) &#123;</span><br><span class="line">				buffer.flip();</span><br><span class="line">				out.write(buffer);</span><br><span class="line">				buffer.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接从InetAddress打开SocketChannel</li>
<li>创建缓存区并立即从SocketChannel读取数据到缓存区</li>
<li>将System.out也包装成Channel,将缓存数据写入Channel中，over</li>
</ul>
<p>read其实是阻塞的一个方法，但是如果你对SocketChannel</p>
<p><code>client.configureBlocking(false)</code> 开启非阻塞模式，read会在没有读取什么数据也返回0 因此此时做循环有区别了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n=client.read(buffer);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        out.write(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//服务器崩了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上我们看到客户端用通道和缓存区好像没啥用，感觉这个对服务器才有点作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverChannel =ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个通道未监听端口，所以要绑定，这个端口通过InetSocketAddress传递</span></span><br><span class="line">ServerSocket ss=serverChannel.socket();</span><br><span class="line">ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">19</span>));</span><br><span class="line"><span class="comment">//或者 serverChannel.bind(new InetSocketAddress(19))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听  返回一个通道 叫客户端通道</span></span><br><span class="line">SocketChannel clientChannel=serverChannel.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//你会希望这个返回的通道是非阻塞的，因为这样允许服务器处理多个并发连接</span></span><br><span class="line">clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServerSocketChannel设置为非阻塞模式，这个accept方法就不会阻塞了</span></span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Selector</span></span><br><span class="line">Selector selector=Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让通道进行注册，然后就能让选择器进行监听</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器通道监听 OP_ACCEPT事件代表该通道准备好接受一个新连接</span></span><br><span class="line">serverChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端也要进行监听注册</span></span><br><span class="line">SelectionKey key=clientChannel.register(selector,SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后安排监听器的事情</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    <span class="comment">//xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听到事件，找到就绪通道后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt;readyKeys=selector.selectedKeys();</span><br><span class="line">Iterator iterator=readyKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    SelectionKey key=iterator.next();</span><br><span class="line">    <span class="keyword">try</span>&#123;   <span class="comment">//可能抛出IOException异常</span></span><br><span class="line">        <span class="comment">//通过事件判断是服务器通道</span></span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">            ServerSocketChannel server=(ServerSocketChannel)key.channel();</span><br><span class="line">            <span class="comment">//得到一个新的客户端通道</span></span><br><span class="line">            SocketChannel connection=server.accept();</span><br><span class="line">            <span class="comment">//异步处理并交给selector</span></span><br><span class="line">            connection.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            connection.register(selector,SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWriteable())&#123;</span><br><span class="line">            SocketChannel client=(SocketChannel)key.channel();</span><br><span class="line">            <span class="comment">//数据写入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除该键，代表已处理</span></span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个新发现的点</p>
<ul>
<li>ServerSocketChannel 也能交个selector上管理 并且知道OP_ACCEPT是用在服务器SocketChannel的</li>
<li>SelectionKey的迭代对象中的channel方法可获得channel不过要强制转换类型一下</li>
<li>通过判断事件可以区分两个不同的通道</li>
<li>实在不行其实可以用两个selector进行区分</li>
</ul>
<p>还有key本身是可以加上一个附件 attachment 这个附件一般是缓冲区ByteBuffer</p>
<p>rewind  把position设为0，limit不变，<strong>一般在把数据重写入Buffer前调用 </strong> 结果却可以调用一些get方法</p>
<p>有了NIO不代表不需要线程，多线程肯定牛啤酒啦，8过，有了NIO的存在，意味着线程和连接就不用1：1了</p>
<p>缓冲区中有个很特别的东西</p>
<p><code>buffer.array()</code>这个是将缓冲区以数组形式返回，这个数组和缓冲区是关联的，修改他们会影响另一个</p>
<p><code>ByteBuffer.allocateDirect(100)</code> 这种好像是VM在系统的缓冲区上直接使用内存访问，以实现ByteBuffer的分配，不搞花里胡哨的后备数组</p>
<p>但此时不能直接用array 和 arrayOffset 会出错，直接缓冲区速度更快，对缓冲区很大时更好，但创建它的代价很高，所以只持续时间比较短的时候用。其细节非常依赖VM 所以不要随便弄</p>
<p>包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data=<span class="string">"Some data"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuffer buffer1=ByteBuffer.wrap(data);</span><br><span class="line"><span class="keyword">char</span>[] text=<span class="string">"Some text"</span>.toCharArray();</span><br><span class="line">CharBuffer buffer2=CharBuffer.wrap(text);</span><br></pre></td></tr></table></figure>
<p>将一个数组直接包装在缓存里面。，其实就是将其作为它的后备数组，这意味着包装创建的缓冲区不是直接缓存区。</p>
<p>而且意味着缓冲区和数组的数据会相互影响</p>
<p>buffer.get() 获取该缓存区的元素，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    result+=buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有 buffer.get(int index) 绝对位置的获取   同理有 put(int index,byte b)</p>
<p>另外绝对位置不会改变position位置</p>
<p>另外还有批量处理</p>
<p>get(byte[] ds,int offset,int length)</p>
<p>get(byte[] ds)</p>
<p>put(byte[] array, int offset, int length)</p>
<p>put(byte[] array)</p>
<p>数据转换  就是ByteBuffer可以弄成其他数据类型</p>
<p>getChar() /getChar(int index,char value)  getChar(int index)/putChar(int index,char value)</p>
<p>同理还有short int long float double</p>
<p>  Buffer可以将字节序列解释为big-endain 或 little-endian 的  int float double 默认是big-endian 可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(buffer.order().equals(ByteOrder.BIG_ENDIAN))&#123;</span><br><span class="line">    buffer.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如用二进制数据测试网络</p>
<p>可能会暴露出一些问题 </p>
<ul>
<li>老的网关配置会出去每个字节的高位 2^30字节就丢一个字节  或因为预料之外的控制字符进行诊断模式</li>
</ul>
<p>视图缓冲区</p>
<p>虽然Socket连接中你只能用ByteBuffer 但其实你可以以int double等这种更高级的数据类型去看待读写，但这就需要将ByteBuffer进行包装，变成视图缓冲区。注意试图缓冲区和底层缓冲区的影响是共享的。不过他们的位置和限度是相互独立的。</p>
<p>还要注意在非阻塞工作的时候，读写上层视图缓存区，要将ByteBuffer中数据排空，非阻塞模式不能保证缓存区在排空后仍以int、double\char类型边界对齐，可能到最后只写入一个字节什么的那就坑爹了。</p>
<p>ShortBuffer asShortBuffer()  这样就让ByteBuffer视图包装成一个ShortByte</p>
<p>其他的还有char int long float double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">intgenClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">1918</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			SocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, DEFAULT_PORT);</span><br><span class="line">			SocketChannel client=SocketChannel.open(address);</span><br><span class="line">			ByteBuffer buffer=ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">			IntBuffer view=buffer.asIntBuffer();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> expected=<span class="number">0</span>;;expected++) &#123;</span><br><span class="line">				client.read(buffer);    <span class="comment">//通道读取到ByteBuffer里</span></span><br><span class="line">				<span class="keyword">int</span> actual=view.get();   <span class="comment">//然后通过视图去获得一整个int  直接通过byteBuffer 去get没有用，因为取一个字节没用，</span></span><br><span class="line">				buffer.clear();</span><br><span class="line">				view.rewind();   <span class="comment">//准备再被read</span></span><br><span class="line">				<span class="keyword">if</span>(actual!=expected) &#123;</span><br><span class="line">					System.err.println(<span class="string">"Expected "</span>+expected+<span class="string">"; was "</span>+actual);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(actual);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子说明视图缓冲区还是很重要的，因为我们知道SocketChannel中的传输都是用ByteBuffer，而有时候我们需要把这些字节解释为Int 这就需要其他的视图缓冲区的帮助</p>
<p>虽然可以用视图缓冲区进行读入和排空，但是呢 SocketChannel这个傲娇的家伙只允许和ByteBuffer进行交流</p>
<p>压缩缓冲区</p>
<p>缓冲有一个 compact方法 ，和clean有点像， 就是将读过的数据清除，然后将还没读取的数据搬到缓冲区前面</p>
<p>对于非阻塞IO进行复制时（读取一个通道，然后将数据写入另一个通道中），压缩是一个特别有用的操作。</p>
<p>这样可以读一部分，写一部分，压缩数据。这样一次IO过程就能完成几次随机的交替的读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key.isWritable()) &#123;</span><br><span class="line">	SocketChannel client=(SocketChannel)key.channel();</span><br><span class="line">	ByteBuffer buffer=(ByteBuffer)key.attachment();</span><br><span class="line">	buffer.flip();</span><br><span class="line">	client.write(buffer);</span><br><span class="line">	buffer.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种只能解决写的部分，但是读的好像并没有类似的操作。</p>
<p>复制缓冲区</p>
<p>如果需要将缓冲区一个相同的信息分发到多个通道，这就需要建立缓冲区的副本，</p>
<p>duplicate() </p>
<p>复制的缓冲区共享相同数据，都是共享影响的。但是初始和缓冲区都有独立的标记、限度和位置。这允许每个通道按照自己的速度读取缓冲区什么的，就很好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">    					SocketChannel client=(SocketChannel)key.channel();</span><br><span class="line">					ByteBuffer buffer=ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						client.read(buffer);   </span><br><span class="line">                        <span class="comment">//这里其实是应该读取客户端到底发了什么再做响应，但这里就忽略了，发送一样的响应</span></span><br><span class="line">						key.interestOps(SelectionKey.OP_WRITE);      <span class="comment">//这个很有趣更改监听的事件</span></span><br><span class="line">						key.attach(contentBuffer.duplicate());          </span><br><span class="line">                        <span class="comment">//这里将成员变量contentBuffer进行复制</span></span><br><span class="line">					&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的重点就是对数据成员对象contentBuffer的复制，这样多个socket都能共享同一个缓冲区，然后<code>key.interestOps(SelectionKey.OP_WRITE)</code>这个改变了监听事件挺有趣的</p>
<p>ServerSocketChannel可以在非阻塞模式 <code>configureBlocking(false)</code>工作，这样accept不会阻塞，可能返回null，这适合需要为每个连接完成大量工作的服务器。</p>
<p>accept方法出错会返回IOException 其实还有几个子类可以指出更详细的问题</p>
<p>ClosedChannelException </p>
<p>AsynchronousCloseException </p>
<p>ClosedByInterruptException </p>
<p>NotYetBoundException </p>
<p>SecurityException</p>
<p>Java7 引入AsynchronousSocketChannel 和 AsynchronousServerSocketChannel类 和SocketChannel 和 ServerSocketChannel很像     但不是子类</p>
<p>特别的是他们干什么本身就是异步的  甚至在IO完成前就返回。 读/写数据会由一个Future或CompletionHandler进一步处理。connect() 和accept()方法都会异步执行，并且返回Future ，这里就不需要用Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress adress=<span class="keyword">new</span> InetSocketAddress(args[<span class="number">0</span>],port);</span><br><span class="line"><span class="comment">//创建一个AsynchronousSocketChannel</span></span><br><span class="line">AsynchronousSocketChannel client=AsynchronousSocketChannel.open();</span><br><span class="line"><span class="comment">//然后连接返回一个connect对象，代表连接</span></span><br><span class="line">Future&lt;Void&gt; connected=client.connect(address);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer=ByteBuffer.allocate(<span class="number">74</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待连接完成</span></span><br><span class="line">connected.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接读取</span></span><br><span class="line">Future&lt;Integer&gt;future=client.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//..做别的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待读取完成</span></span><br><span class="line">future.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//回绕并排空缓冲区</span></span><br><span class="line">buffer.flip();</span><br><span class="line">WritableByteChannel out=Channels.newChannel(System.out);</span><br><span class="line">out.write(buffer);</span><br></pre></td></tr></table></figure>
<p>这种方法可以用于有顺序的获取结果，如果你不关心顺序，可以用CompletionHandler</p>
<p>这个接口声明两个接口 completed() failed()   代表完成调用或者出现IO错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">ByteBuffer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result,ByteBuffer buffer)</span></span>&#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        WritableByteChannel out=Channels.newChanel(System.out);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            out.write(buffer);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123; System.err.println(ex);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable ex,ByteBuffer attachment)</span></span>&#123;</span><br><span class="line">        System.err.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer=ByteBuffer.allocate(<span class="number">74</span>);</span><br><span class="line">CompletionHandler&lt;Integer,ByteBuffer&gt;handler=<span class="keyword">new</span> LineHandler();</span><br><span class="line">channel.read(buffer,buffer,handler);</span><br></pre></td></tr></table></figure>
<p>读取通道，要向read传入一个缓冲区，一个附件和一个CompletionHandler，这里将buffer也作为附件。</p>
<p>另一个常用的模式是将CompletionHandler作为匿名内部类，缓冲区作为作为一个最终局部变量，将缓冲区放入处理器的作用域当中。</p>
<p>尽管可以多线程共享一个AsynochronousSocketChannel 或者 xxServerSocketChannel 但是一次只有一个线程可以读取/写入这个通道。（但是可以一个线程读一个线程写）</p>
<p>Socket选项</p>
<p>Channel们都实现了NetworkChannel接口用支持TCP选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getOption(SocketOption&lt;T&gt;name)</span><br><span class="line">setOption(SocketOption&lt;T&gt;name,T value)</span><br><span class="line">supportedOptions()</span><br></pre></td></tr></table></figure>
<p>这个SocketOption 是一些常量 StandardSocketOptions</p>
<ul>
<li>IP_MULTICAST_IF</li>
<li>IP_MULTICAST_LOOP</li>
<li>IP_TOS</li>
<li>xxxx</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NetworkChannel channel=SocketChannel.open();</span><br><span class="line">channel.setOption(StandardSocketOptions.SO_LINGER,<span class="number">240</span>);</span><br></pre></td></tr></table></figure>
<p>很奇怪虽然supportedOptions 中是有 IP_TOS 而且在StandradSocketOptions 中有设置，但好像并不能 getOptions这个东西，即使设置过了</p>
<p>注意</p>
<ul>
<li>不是所有通道都允许给selector管理的，比如fileChannel 但是网络通信的channel都行</li>
<li>select(long timeout) 超时设置</li>
<li>selector.close() 会释放所有键和所有被select阻塞的线程都会通畅</li>
<li>SelectionKey 的cancel方法 用来撤销注册</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Java网络编程(五)URL和URI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Java网络编程(五)URL和URI/" itemprop="url">Java网络编程(五)URL和URI</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>URL是URI的一种表示方式</p>
<p>URI的语法</p>
<p>模式:模式特定部分 （模式特定部分的语法取决于所用的模式）</p>
<p>data    连接重直接包含的base64编码数据<br>file    本地磁盘文件<br>ftp<br>http<br>mailto  电子邮件地址<br>magnet 对等网络可以下载的资源<br>telnet 与基于telnet的服务的连接</p>
<p>urn 统一资源名  还有其他非标准的 rmi jar jndi doc</p>
<p>URI没有特定的语法，不过大都采用一种层次结构的形式</p>
<p>//authority/path?query</p>
<p>authority 代表解析该URI的其余部分的授权机构 </p>
<p>比如  <a href="http://www.baidu.com/ca/abc?key=233" target="_blank" rel="noopener">http://www.baidu.com/ca/abc?key=233</a></p>
<p>授权机构 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>路径 /ca/abc              不过这个部分不全是路径  有可能是一个数据库的提取信息的参数 也可以代表一个会话钥匙<br>请求 key=233</p>
<p>但有些uri表示不分层，也有些是通过.而不是/来进行分层</p>
<p>非ascll得字母和数字 要用%号进行转移 后面加上它得UTF-8的16进制的编码</p>
<p>如果没有将非ascll字符按上述编码而是将其直接放在URI中，这个是IRI　但很多协议和软件只接受和支持URI</p>
<p>如果不是用于特定的部分　／　和　＠都要进行编码</p>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>这是一个final类 不能对其派生</p>
<p>URL 对象是不可改变的，他是线程安全的</p>
<h4 id="构造URL"><a href="#构造URL" class="headerlink" title="构造URL"></a>构造URL</h4><p>构造函数</p>
<p>URL(String url)<br>URL(String protocol,String hostname,String file)   file前记得要加/<br>URL(String protocol,String hostname,int port,String file)  port设为-1说明用协议默认端口<br>URL(URL base,String relative)  base是一个完整的指向file的路径了 relative不用/</p>
<p>除了验证能否识别URL的模式之外，不支持则会抛出MalformedURLException，java不会对url做其他检查</p>
<p>其他URL对象来源</p>
<p>java类库中其他的方法也返回URL对象</p>
<p>applet中调用 getDocumentBase() 返回这个applet的页面的URL getCodeBase() 该applet的class文件的URL</p>
<p>java.io.File 有一个toURL() 他会返回指定文件匹配的file URL  这个方法会返回URL格式和平台相关</p>
<p>类加载器能加载资源 它的静态方法  ClassLoader.getSystemResource(String name) 返回URL 通过它可以读取一个资源</p>
<p>ClassLoader.getSystemResources(String name) 返回一个Enumeration 包含一个URL列表</p>
<p>getResource(String name) 会在引用类加载器使用的路径中搜索指定资源的URL</p>
<p>java.swing.JEditorPane的getPage() 和java.net.URLConnection getURL()</p>
<h4 id="从URL获取数据"><a href="#从URL获取数据" class="headerlink" title="从URL获取数据"></a>从URL获取数据</h4><p>我们接下来介绍如何往URL类压榨数据</p>
<p>InputStream openStream()<br>URLConnection openConnection()<br>URLConnection openConnection(Proxy proxy)<br>Object getContent()<br>Object getContent(Class[]classes)</p>
<p>InputStream openStream()  这个对象获得的资源是原始内容未经解释 它不包含任何http首部或者协议相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.nio.charset.MalformedInputException;</span><br><span class="line"></span><br><span class="line">public class sourceViewer &#123;</span><br><span class="line">	public static void main(String[]args) &#123;</span><br><span class="line">		if(args.length&gt;0) &#123;</span><br><span class="line">			InputStream inputStream=null;</span><br><span class="line">			try &#123;</span><br><span class="line">				URL url=new URL(args[0]);</span><br><span class="line">				inputStream=url.openStream();</span><br><span class="line">				inputStream=new BufferedInputStream(inputStream);</span><br><span class="line">				Reader reader=new InputStreamReader(inputStream);</span><br><span class="line">				int c;</span><br><span class="line">				while((c=reader.read())!=-1) &#123;</span><br><span class="line">					System.out.print((char)c);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch(MalformedInputException ex) &#123;</span><br><span class="line">				System.err.println(args[0]+&quot;is not a parseable URL&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			catch(IOException ex) &#123;</span><br><span class="line">				System.err.println(ex);</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">				if(inputStream!=null) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						inputStream.close();</span><br><span class="line">					&#125;</span><br><span class="line">					catch (IOException e) &#123;</span><br><span class="line">						// TODO: handle exception</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个不可靠的地方就是 远程主机和本地客户端可能采用不同的默认字符集。如果页面使用了与Ascll完全不同字符集而无法识别Meta标记或http头部什么的。导致编码错误</p>
<p>URLConnection openConnection()</p>
<p>openConnection() 打开socket，并返回一个URLConnection()对象  它表示一个网络资源打开的连接 调用失败出IOException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    URL u=new URL(&quot;http://xxxx&quot;);</span><br><span class="line">    try&#123;</span><br><span class="line">        URLConnection uc=u.openConnection();</span><br><span class="line">        &lt;!--通过URLConnection去获取输入流--&gt;</span><br><span class="line">        InputStream in=uc.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    catch(MalformedURLException ex)&#123;</span><br><span class="line">        System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URLConnection允许你访问http首部以及原始的html 除了URL读取，还允许你向url写入数据</p>
<p>URLConnection openConnection(Proxy proxy)  这个版本就指定通过哪个代理服务器传递连接</p>
<p>Object getContent()  会根据数据内容尝试建立一个某种类型的对象 如果是文本内容则返回InputStream 如果是图像则返回一个ImageProducer<br>不过返回的是Object 要强制类型转换你要的类型   </p>
<p>它会从服务器的数据首部查找的Content-type 字段，如果服务器没有MiMe首部或者给了不熟悉的类型就会返回输入流 如果出错则返回IOException</p>
<p>Object getContent(Class[]classes)   指定你想要返回的类型  你可以传个数组代表你希望返回的类型的优先列表</p>
<h3 id="分解URL"><a href="#分解URL" class="headerlink" title="分解URL"></a>分解URL</h3><p>URL 对象可以通过一些成员方法得到一些部分的url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String getProtocol()  得到模式</span><br><span class="line"></span><br><span class="line">String getHost() 返回主机</span><br><span class="line"></span><br><span class="line">int getPort() 返回端口 没明确指明则返回-1</span><br><span class="line"></span><br><span class="line">int getDefaultPort() URL没有指定端口，该方法返回这个url协议所使用的默认端口</span><br><span class="line"></span><br><span class="line">String getFile() 返回路径 （第一个斜线后的内容到#前）</span><br><span class="line"></span><br><span class="line">String getPath() 返回路径但不包含查询的部分</span><br><span class="line"></span><br><span class="line">String getRef() 返回片段标识符的部分 #后的部分</span><br><span class="line"></span><br><span class="line">String getQuery() 返回查询字符串 如果没有返回null</span><br><span class="line"></span><br><span class="line">String getUserInfo() 返回用户信息 /后 @ 前面的内容  但是对于mailto模式的@ 不代表用户 整个代表路径 其实是指接收方的用户</span><br><span class="line"></span><br><span class="line">String getAuthority() 返回权威机构 // 。。。。/中的内容可能包含 用户信息 和端口内容</span><br></pre></td></tr></table></figure>
<p>相等性和比较</p>
<p>URL的比较 是要在同一主机 路径 资源 这才是相同 然后equals() 返回true  equals()通过DNS去解析主机来判断两个主机相同但不会比较两个URL标识的资源 比如加个端口省略默认资源什么的就不认识了</p>
<p>实际上equals是一个阻塞IO的操作 所以不要将URL存储在依赖equals的数据结构当中比如HashMap 更好选择是URI</p>
<p>sameFile() 这个比较和equals基本相同 但它不考虑片段的标识符</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>toString()  生成String对象 而且URL时绝对URL  往往是用于做隐式调用的<br>toExternalForm() 将URL对象转为字符串  实际上toString()所做的事情就是返回toExternalForm()<br>toURI() 将URL对象转换为URI对象      </p>
<p>URI类 提供了比URL类更准确，更符合规范的行为。对于绝对化和编码等操作，应当首选URI类，因为它的equals方法不会阻塞，而URL类应当从事服务器下载的任务</p>
<p>URI是对URL的抽象，不仅包括统一资源定位符，还包括统一资源名（URN） 实际使用上URI大多是URL 但大多数标准是用URI定义的</p>
<ul>
<li>URI类完全有关于资源的标识和URI的解析，它没有提供方法去获取</li>
<li>URI的规范更加一直</li>
<li>URI可以代表相对的地址，但URL在存储URI之前会将其绝对化地址</li>
</ul>
<p>如果你是想下载一个URL内容，就用URL 如果是完成标识而不是获取，则使用URI类 二者都需要时 其实可以通过toURL 和 toURI 相互转换</p>
<h3 id="构造URI"><a href="#构造URI" class="headerlink" title="构造URI"></a>构造URI</h3><ul>
<li>URI(String uri)</li>
<li>URI(String scheme,String schemeSpecificPart,String fragment)</li>
<li>URI(String scheme,String host,String path,String fragment)</li>
<li>URI(String scheme,String authority,String path,String query)</li>
<li>URI(String scheme,String userInfo,String host,int port,String path,String query,String fragment)</li>
</ul>
<p>与URL类不同，URI类不依赖底层协议处理器，所以只要URI语法正确，Java就不需要为了创建URI对象而理解其协议。</p>
<p><strong>URI(String uri)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI voice=<span class="keyword">new</span> URI(<span class="string">"tel:+1-800-9988-9938"</span>);</span><br><span class="line">URI web=<span class="keyword">new</span> URI(<span class="string">"http://www.xml.com/pub/a/..."</span>);</span><br><span class="line">URI book=<span class="keyword">new</span> URI(<span class="string">"urn:isbn:1-565-92870-9"</span>);</span><br></pre></td></tr></table></figure>
<p>如果语法不正常的话，比如冒号开头，这个构造函数将抛出一个URISyntaxException 异常 这是一个受查异常，所以要捕获这个异常。 或者调用构造函数的方法中声明可能抛出该异常 URI中可以包括其他的Unicode字符</p>
<p>剩下我就不一个个构造函数讲了，就讲一下参数的意义</p>
<p>scheme 模式 是URI的协议如http urn tel    必须字母数字 和（+-.） 组成  如果传入null 则省略，创建相对uri</p>
<p>schemeSpecificPart  模式特定部分，取决于URI模式的语法　　和scheme相关  不和规矩的字符会用百分号来转义</p>
<p>fragment 片段标识符    #号后面的内容 可以传null</p>
<p>host/authority path 用于层次的URI 比如http ftp  指定主机和路径  host <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  path /xxxb/cc</p>
<p>query 用于表示？ 之后的东西  代表参数</p>
<p>userinfo 代表用户信息</p>
<p>port 代表端口</p>
<p>如果你确信你的URI是有效的，不违反规则，可以使用静态工厂方法URI.create() 与构造函数不同，不抛出URISyntaxException异常 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI styles=URI.create(<span class="string">"xxxxx"</span>);</span><br></pre></td></tr></table></figure>
<p>如果是不正确的，方法则会抛出一个IlleagalArgumentException的运行异常</p>
<p>URI各部分的获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URISplitter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length();i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                URI u=<span class="keyword">new</span> URI(args[i]);</span><br><span class="line">                System.out.println(<span class="string">"The url is "</span>+u);</span><br><span class="line">                <span class="keyword">if</span>(u.isOpaque())&#123;   <span class="comment">//判断是否为层次URI</span></span><br><span class="line">            	  	System.out.println(<span class="string">"这是一个层次URI"</span>);</span><br><span class="line">                	System.out.println(<span class="string">"the scheme is"</span>+u.getScheme());</span><br><span class="line">                  	System.out.println(<span class="string">"the scheme specific part is "</span>+u.getSchemeSpecificPart());</span><br><span class="line">                    System.out.println(<span class="string">"the fragment id is "</span>+u.getFragment());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"this is a hierarchical url."</span>);</span><br><span class="line">                    System.out.println(<span class="string">"the scheme is"</span>+u.getScheme());</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        u=u.parseServerAuthority();   <span class="comment">//将authority进行划分？</span></span><br><span class="line">                        System.out.println(<span class="string">"the host is"</span>+u.getHost());</span><br><span class="line">                        System.out.println(<span class="string">"the user info is"</span>+u.getUserInfo());</span><br><span class="line">                        System.out.println(<span class="string">"the port is"</span>+u.getPort());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span>(URISyntaxException ex)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"the authority is"</span>+u.getAuthority());</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"the path is"</span>+u.getPath());</span><br><span class="line">                    System.out.println(<span class="string">"the query string is"</span>+u.getQuery());</span><br><span class="line">                    System.out.println(<span class="string">"fragment id is"</span>+u.getFragment());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(URISyntaxException ex)&#123;</span><br><span class="line">                System.err.println(args[i]+<span class="string">"does not seem to be a URI."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析拼接URI</p>
<p>主要是两个 resolve(URI/String) relativize(URI)  都返回URI</p>
<p>resolve用于拼接 而relativize 用于分解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URI a=<span class="keyword">new</span> URI(<span class="string">"www.bb.com/"</span>);</span><br><span class="line">URI b=<span class="keyword">new</span> URI(<span class="string">"login.jpg"</span>);</span><br><span class="line">URI c=b.resolve(a);         <span class="comment">//c www.bb.com/login.jpg</span></span><br><span class="line"></span><br><span class="line">URI a=<span class="keyword">new</span> URI(<span class="string">"www.bb.com/login.jpg"</span>);    </span><br><span class="line">URI b=<span class="keyword">new</span> URI(<span class="string">"www.bb.com/"</span>);</span><br><span class="line">URI c=b.relativize(a);           <span class="comment">//c login.jpg</span></span><br></pre></td></tr></table></figure>
<p>相等性和比较</p>
<p>可以测试URI的相等性，这不是直接的字符串比较，</p>
<ul>
<li>相等的URI必须都是层次的或是不透明的。</li>
<li>比较时模式和授权机构（不透明）主机（透明）不考虑大小写。  其他则区分</li>
<li>转义字符比较前不解码</li>
</ul>
<p>hashCode()方法和相等性是一样的，相等的URI则有相同的散列码</p>
<p>比较是从左往右 不过模式比是否层次的优先级更高一点</p>
<p><strong>URI的字符串表示</strong></p>
<p>toString()              URI未编码的字符串形式  （所以可能是无法识别的URI）</p>
<p>toASCLLString()    URI的编码的字符串的形式</p>
<p>x-www-form-urlencoded</p>
<p>我们使用Ascll的子集 来作为URL的组成字符</p>
<p>其他不识别的字符全部转换为字节，每个字节都要写为百分号后面加两个十六进制数字</p>
<p>空格可以编码为%20 或者+    +号本身可以编码为%2B</p>
<p>/ # = &amp; ？ 字符用在名字中应当编码，但作为URL各部分的分隔符时不用编码</p>
<p>用getPath() toExternalForm() 等方法输出时，这样的字符和转义字符不会自动编码或解码</p>
<p>java提供 URLEncoder 和 URLDecoder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String encoded=URLEncoder.encode(<span class="string">"hhttp://asd/.."</span>,<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p>他会返回对URL进行编码，甚至将能识别的波浪线感叹号等符号转为百分号转义字符，但URL规范不禁止这种转换，所以Web浏览器会合理地处理这些过度编码URL</p>
<p>编码最好选择UTF-8更兼容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加url的参数 但好像构造函数没写好。。。url本身没有，，可以在后期参数加在url中 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryString</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder query=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name,String value)</span></span>&#123;</span><br><span class="line">        query.append(<span class="string">'&amp;'</span>);</span><br><span class="line">        encode(name,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String name,String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            query.append(URLEncoder.encode(name,<span class="string">"UTF-8"</span>));</span><br><span class="line">            query.append(<span class="string">'='</span>);</span><br><span class="line">            query.append(URLEncoder.encode(value,<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(UnsupportedEcodingException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"VM does not support utf-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getQuery();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URLDecoder</p>
<p>URLDecoder 有一个静态方法decode() 会对用x-www-form-url-encoded 格式编码字符串进行解码 就是编码的逆操作</p>
<p>static String decode(String s,String encoding) throws UnsupportedEncodingException 编码方式一般为UTF-8</p>
<p>如果字符串的%号后没有两个十六进制数字，或字符串解码为无效序列，则返回IllegalArgumentException异常</p>
<p>代理</p>
<p>如果时用纯粹的http的代理 将http.proxyHost 设置为代理服务器的域名或IP地址，http.proxyPort 设置代理服务器的端口</p>
<p>还有一些其他方法，包括java代码调用System.setProperty()                   p154-155 不懂克</p>
<p>Proxy类</p>
<p>Proxy类允许从java程序中对代理服务器更细粒度的控制  代理本身用java.net.Proxy 实例表示 </p>
<p>三种代理模式 HTTP SOCKS 和直接链接</p>
<ul>
<li>Proxy.Type.DIRECT</li>
<li>Proxy.Type.HTTP</li>
<li>Proxy.Type.SOCKS</li>
</ul>
<p>关于代理的地址和端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress addr=<span class="keyword">new</span> InetSocketAddress(<span class="string">"xxx.com"</span>,<span class="number">80</span>);</span><br><span class="line">Proxy proxy=<span class="keyword">new</span> Proxy(Proxy.Type.HTTP,addr);</span><br></pre></td></tr></table></figure>
<p>ProxySelector 类</p>
<p>每个运行的虚拟机都有一个proxyselector 对象 用来确定不同链接的代理服务器  默认只会检查各种系统属性和URL协议  我们可以安装自己的ProxySelector子类代替默认的选择器 用它的协议主机路径日期和其他标准选择不同代理</p>
<p>实现这个类的关键是实现select的方法</p>
<ol>
<li><p>abstract List<proxy> select (URI uri)  根据URI对象选择合适的代理放入队列中</proxy></p>
</li>
<li><p>void connectFailed(URI uri,SocketAddress addr,IOException ex)  回调方法，用来警告程序这个代理服务器并没有建立链接</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">localproxyselector</span> <span class="keyword">extends</span> <span class="title">ProxySelector</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;URI&gt; failed=<span class="keyword">new</span> ArrayList&lt;URI&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Proxy&gt; <span class="title">select</span><span class="params">(URI uri)</span></span>&#123;</span><br><span class="line">        List&lt;Proxy&gt; result=<span class="keyword">new</span> ArrayList&lt;Proxy&gt;();</span><br><span class="line">        <span class="comment">//是失败的uri或者非http协议的uri</span></span><br><span class="line">        <span class="keyword">if</span>(failed.contains(uri)|| !<span class="string">"http"</span>.equalsIgnoreCase(uri.getScheme()))&#123;</span><br><span class="line">            result.add(Proxy.NO_PROXY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//先建立socketAddress 再建立Proxy</span></span><br><span class="line">            SocketAddress proxyAddress=<span class="keyword">new</span> InetSocketAddress(<span class="string">"proxy.example.com"</span>,<span class="number">8000</span>);</span><br><span class="line">            Proxy proxy=<span class="keyword">new</span> Proxy(Proxy.Type.HTTP,proxyAddress);</span><br><span class="line">            result.add(proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失败的回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri,SocketAddress addr,IOException ex)</span></span>&#123;</span><br><span class="line">        failed.add(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但前面所述，每个虚拟机只有一个ProxySelector 而且已经有默认的了 需要改变默认的selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProxySelector selector=<span class="keyword">new</span> LocalProxySelector();</span><br><span class="line">ProxySelector.setDefault(selector);</span><br></pre></td></tr></table></figure>
<p>一般不要在某个servlet中改变proxyselector 因为这会改变整个</p>
<p>通过GET与服务器端程序通信</p>
<p>说到底就是从表单获取元素，构造新URL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">aa</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String target=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            target+=args[i]+<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target=target.trim();</span><br><span class="line">        <span class="comment">//将其包装成QueryString</span></span><br><span class="line">        QueryString query=<span class="keyword">new</span> QueryString();</span><br><span class="line">        query.add(<span class="string">"q"</span>,target);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.xxx.org/search/q?"</span>+query);</span><br><span class="line">            <span class="comment">//通过uri获取输入流 然后将页面写出来</span></span><br><span class="line">            <span class="keyword">try</span>(InputStream in =<span class="keyword">new</span> BufferedInputStream(u.openStream()))&#123;</span><br><span class="line">                InputStreamReader thehtml=<span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">                <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">while</span>((c=thehtml.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(MalformedURLException ex)&#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问口令的保护网站</p>
<p>Authenticator类 可以用它使用http认证自我保护的网站提供用户名和口令</p>
<p>但这是个抽象类，必须派生子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置默认的认证程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefault</span><span class="params">(Authenticator a)</span></span></span><br></pre></td></tr></table></figure>
<p>当URL类需要用户名和口令时，会使用Authenticator.requestPasswordAuthentication() 去访问这个Authentication子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PasswordAuthentication <span class="title">requestPasswordAuthentication</span><span class="params">(InetAddress addr,<span class="keyword">int</span> port,String protocol,String prompt,String scheme)</span><span class="keyword">throws</span> SecurityException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>addr 需要认证的主机 </li>
<li>port是该主机上的端口 </li>
<li>protocol 访问网站的应用层协议  </li>
<li>http服务器提供prompt一般是需要认证的域和域名   比如一个大的Web服务器会有多个域 每个域有不同的用户名和口令  </li>
<li>scheme是所使用的认证模式（不是协议 比如说http的认证模式为basic）</li>
</ul>
<p>不可信的applet不允许向用户询问用户名和口令，可信任的才可以访问，但只有在拥有requestPasswordAuthentication NetPermission 权限才允许   否则Authenticator.requestPasswordAuthentication 会抛出一个SecurityException</p>
<p>Authenticator子类必须覆盖getPasswordAuthentication()方法 在这个方法中，要从用户或其他来源收集用户名和口令，把它作为java.net,PasswordAuthentication 类的一个实例返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果不希望对这个请求完成认证，就返回null，Java会告诉服务器它不知道如何认证这个链接。如果你提交了不正确的认证，会再次调用 getPasswordAuthentication()  给你再次输入，连续5次把，如果还是错 则抛出ProtocolException</p>
<p>用户名和口令将缓存在同一个虚拟机会话中，一旦设置好口令就不应再次询问，除非将包含这个口令的char数组清零</p>
<p>Authenticator的超类有很多方法 去获得相关请求认证url的各种信息</p>
<h2 id="PasswordAuthentication"><a href="#PasswordAuthentication" class="headerlink" title="PasswordAuthentication"></a>PasswordAuthentication</h2><p>这是个final类 支持两个只读属性 用户名（String) 口令（char数组） </p>
<p><code>PasswordAuthentication(String userName,char[] password)</code></p>
<p><code>public String getUserName()</code></p>
<p><code>public char[] getPassword()</code></p>
<h2 id="JPasswordField"><a href="#JPasswordField" class="headerlink" title="JPasswordField"></a>JPasswordField</h2><p>该类用来当作文本域,不过口令部分是变成星号  这是来自swing的组件</p>
<p><code>public class JPasswordField extends JTextField</code></p>
<p>它的口令存储为char[]</p>
<p><code>public char[] getPassword()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java....</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DialogAuthenticator</span> <span class="keyword">extends</span> <span class="title">Authenticator</span></span>&#123;   <span class="comment">//继承Authenticator</span></span><br><span class="line">        <span class="keyword">private</span> JDialog passwordDialog;</span><br><span class="line">        <span class="keyword">private</span> JTextField usernameField=<span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">private</span> JPasswordField passwordField=<span class="keyword">new</span> JPasswordField(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">private</span> JButton okButton=<span class="keyword">new</span> JButton(<span class="string">"OK"</span>);</span><br><span class="line">        <span class="keyword">private</span> JButton cancelButton=<span class="keyword">new</span> JButton(<span class="string">"Cancel"</span>);</span><br><span class="line">        <span class="keyword">private</span> JLabel mainLabel=<span class="keyword">new</span> JLabel(<span class="string">"Please enter username and password: "</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DialogAuthenticator</span><span class="params">(String username,JFrame parent)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.passwordDialog=<span class="keyword">new</span> JDialog(parent,<span class="keyword">true</span>);</span><br><span class="line">            Container pane=passwordDialog.getContentPane();</span><br><span class="line">            pane.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line">            JLabel userLabel=<span class="keyword">new</span> JLabel(<span class="string">"Username: "</span>);</span><br><span class="line">            JLabel passwordLabel=<span class="keyword">new</span> JLabel(<span class="string">"Password: "</span>);</span><br><span class="line">            pane.add(mainLabel);</span><br><span class="line">            JPanel p2=<span class="keyword">new</span> JPanel();</span><br><span class="line">            p2.add(userLabel);</span><br><span class="line">            p2.add(usernameField);</span><br><span class="line">            usernameField.setText(username);</span><br><span class="line">            pane.add(p2);</span><br><span class="line">            JPanel p3=<span class="keyword">new</span> JPanel();</span><br><span class="line">            p3.add(passwordLabel);</span><br><span class="line">            p3.add(passwordField);</span><br><span class="line">            pane.add(p3);</span><br><span class="line">            JPanel p4=<span class="keyword">new</span> JPanel();</span><br><span class="line">            p4,add(okButton);</span><br><span class="line">            p4.add(cancelButton);</span><br><span class="line">            pane.add(p4);</span><br><span class="line">            passwordDialog.pack();</span><br><span class="line">            </span><br><span class="line">            ActionListener al=<span class="keyword">new</span> OKResponse();</span><br><span class="line">            okButton.addActionListener(al);</span><br><span class="line">            usernameField.addActionListener(al);</span><br><span class="line">            passwordField.addActionListener(al);</span><br><span class="line">            cancelButton.addActionListener(<span class="keyword">new</span> CancelResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String prompt=<span class="keyword">this</span>.getRequestingPrompt();</span><br><span class="line">            <span class="keyword">if</span>(prompt==<span class="keyword">null</span>)&#123;</span><br><span class="line">                String site=<span class="keyword">this</span>.getRequestingSite().getHostName();</span><br><span class="line">                String protocol=<span class="keyword">this</span>.getRequestingProtocol();</span><br><span class="line">                <span class="keyword">int</span> port=<span class="keyword">this</span>.getRequestingPort();</span><br><span class="line">                <span class="keyword">if</span>(site!=<span class="keyword">null</span>&amp;protocol!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    prompt=protocol+<span class="string">"://"</span>+site;</span><br><span class="line">                    <span class="keyword">if</span>(port&gt;<span class="number">0</span>)prompt+=<span class="string">":"</span>+port;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    prompt=<span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mainLabel.setText(<span class="string">"Please enter username and password for"</span>+prompt+<span class="string">": "</span>);</span><br><span class="line">            passwordDialog.pack();</span><br><span class="line">            passwordDialog.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        PasswordAuthentication response=<span class="keyword">null</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">OKResponse</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>&#123;</span><br><span class="line">                passwordDialog.setVisible(<span class="keyword">false</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">char</span>[]password=passwordField.getPassword();</span><br><span class="line">                String username=usernameField.getText();</span><br><span class="line">                passwordField.setText(<span class="string">""</span>);</span><br><span class="line">                response=<span class="keyword">new</span> PasswordAuthentication(username,password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CancelResponse</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>&#123;</span><br><span class="line">                passwordDialog.setVisible(<span class="keyword">false</span>);</span><br><span class="line">                passwordField.setText(<span class="string">""</span>);</span><br><span class="line">                response=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.show();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们要重写的是Authenticator的子类</li>
<li>里面有个重要的类PasswordAuthenication  不用重写但需要好好使用<ul>
<li>通过构造函数 将username 和password构造成PasswordAuthentication对象</li>
<li>要定义好getPasswordAuthentication() 返回构造完成的PasswordAuthentication对象</li>
</ul>
</li>
<li>需要利用好Swing的组件 利用组件和事件监听及时将username和password进行传递</li>
</ul>
<p>但问题是如何设置你得口令什么的是否正确？？？？？？？？？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureSourceViewer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置验证口令</span></span><br><span class="line">        Authenticator.setDefault(<span class="keyword">new</span> DialogAuthenticator());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                URL u=<span class="keyword">new</span> URL(args[i]);</span><br><span class="line">                <span class="keyword">try</span>(InputStream in =<span class="keyword">new</span> BufferedInputStream(u.openStream()))&#123;</span><br><span class="line">                    Reader r=<span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">                    <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span>((c=r.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(MalformedURLException ex)&#123;</span><br><span class="line">                System.err.println(args[<span class="number">0</span>]+<span class="string">"is not a parseable URL"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">                System.err.println(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Java网络编程(十三)组播/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Java网络编程(十三)组播/" itemprop="url">Java网络编程(十三)组播</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h3><p>IP组播是在广播和点对点通信之间 ，他依靠中间爱你网站的复制和中转信息，将信息传送给下游网站（路由器？）</p>
<p>路由器会限制广播会仅限于本地网络或者子网</p>
<p>曾经有种解决方式是 创建静态连接树      数据由起始网站提供给其他服务器，这些服务器再讲将这些数据复制到另外一些路由器，最终复制到客户端。但这种东西比较过时，也因为新网站需要找到一个位置手工加入连接树，而且这个连接树不一定任何时候都是最好的拓扑结构，另外服务器本身需要维护很多指向客户端的点对点连接。所以这是引入组播的理由</p>
<p>组播相比静态连接树，他的智能之处就是，他是将信息比较准确的复制数据发送到一个范围的组播地址，然后这个组播地址再发送给该组的每一个主机。 但其实在Internent上的组播很少用，组播更多是用在某个组织的防火墙内部使用。注意使用这个的时候有一个叫TTL的首部字段，其实是限制数据包转发的次数，从而限制组播的范围。</p>
<p>组播地址是有一个相对比较固定的范围<br>比如IPV4 就是 244.0.0.0 到 239.255.255.255 之间  </p>
<p>组播地址可以有一个主机名，例如 224.0.1.1 就分配有主机名 ntp.mcast.net</p>
<p>除了一些范围内的组播地址块已经为特殊用途所保留，其他剩余的组播地址都可以由任何人有需要时使用。组播路由器负责确保两个不同的系统不会同时使用相同的地址</p>
<p>当一台主机打算向组播组发送数据的时候，它会将数据放在组播数据报中，组播数据报就是发送到组播组的UDP数据报而已。 为什么不用TCP，因为TCP会要求主机确认所有已经接受的报，放在多个主机的组播环境下，效率会低得可怕。<br>如果你的应用程序不允许数据的丢失，那你就要负责确定数据是否损坏而且如何处理，比如你可能需要一个分布式的缓存系统，当数据丢失没可能只用使用之前文件的缓存不做改变</p>
<p>组播和和正常的UDP socket 之间的主要区别是TTL 一般来说</p>
<ul>
<li>本地主机 0</li>
<li>本地子网 1</li>
<li>本地校园网 16</li>
<li>同一个国家的高带宽网站 32</li>
<li>同一个国家所有网站   48</li>
<li>世界内的所有网站 255</li>
</ul>
<p>但如果包是发送到 224.0.0.0 - 224.0.0.255 即 local-link地址 则永远不会发送到本地子网之外</p>
<p>引入组播Socket 导致在任何指定的网段上，相同的数据不会发送多次，实际的路由问题变简化了</p>
<p>组播最大的限制就是是否有特殊的组播路由器或者路由是否启用组播的功能</p>
<p>可以尝试 ping 一下组播地址</p>
<p>ping all-routers.mcast.net 如果有路由器响应，则说明有组播路由器</p>
<p>但即使ping成功也可能无法让你成功组播</p>
<p>组播socket</p>
<p>我们是使用 MulticastSocket 他是DatagramSocket的一个子类</p>
<p>他和DatagramSocket 很像，需要将数据放在DatagramPacket对象中，然后通过MulticastSocket去收发这个DatagramPacket对象</p>
<p><code>MulticastSocket ms=new MulticastSocket(2300);</code> 创建socket，参数代表监听端口。</p>
<p><code>InetAddress group= InetAddress.getByName(&quot;224.2.2.2&quot;);</code><br><code>ms.joinGroup(group);</code><br>将这个socket添加进行组播组</p>
<p>一旦进入组播组，就像一个正常的DatagramSocket就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">DatagramPacket dp=<span class="keyword">new</span> DatagramPacket(buffer,buffer.length);</span><br><span class="line">ms.receive(dp);</span><br></pre></td></tr></table></figure>
<p><code>ms.leaveGroup(group);   ms.close();</code>  离开组播组，然后可以close掉</p>
<p>向组播地址发送数据也一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InetAddress ia=InetAddress.getByName(<span class="string">"experiment.mcast.net"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data=<span class="string">"Here is some cast data \r\n"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">4000</span>;</span><br><span class="line">DatagramPacket dp=<span class="keyword">new</span> DatagramPacket(data,data.length,ia,port);</span><br><span class="line">MultiSocket ms=<span class="keyword">new</span> MultiSocket();</span><br><span class="line">ms.send(dp);</span><br></pre></td></tr></table></figure></p>
<p>组播Socket是一个很大的安全漏洞，所以在SecurityManager控制下运行的不可信代码不允许做任何组播的操作。所以大多数执行远程代码的环境都禁用了组播功能</p>
<p>构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MulticastSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MulticastSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MulticastSocket</span><span class="params">(SocketAddress bindaddr)</span></span></span><br></pre></td></tr></table></figure></p>
<p>能执行一些socket选项的样子 ms.setReuseAddress(false);</p>
<p>一旦创建了MulticastSocket</p>
<ul>
<li>加入组播组</li>
<li>向组中成员发送数据</li>
<li>接收组中的数据</li>
<li>离开组播组</li>
</ul>
<p>必须加入组才能从组接收数据，但向组发送数据并不用先加入组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(InetAddress address)</span>        </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinGroup</span><span class="params">(SocketAddress address,NetworkInterface interface)</span>  <span class="comment">//第二个参数指定网络接口，比如网卡</span></span></span><br></pre></td></tr></table></figure>
<p>试图加入的地址不是组播地址 joinGroup 会抛出IOException</p>
<p>一个MulticastSocket可以加入多个组播组，组播组的成员信息存储在组播路由器中，不在对象中</p>
<p><code>leaveGroup(InetAddress)         leaveGroup(SocketAddress  NetworkInterface)</code>l离开组播组</p>
<p>如果参数不是组播地址 抛出IOException         如果未加入过，则什么都不做</p>
<p>发送组播数据就将 DatagramPacket 包 给MulticastSocket 进行send </p>
<p>注意TTL的情况，默认为 1  可以通过  MulticastSocket 的方法 <code>setTimeToLive()</code>设置默认值，也可以直接进行</p>
<p><code>send(DatagramPacket p,byte ttl)</code>设置ttl,这个优先级比默认的高</p>
<p><code>getTimeToLive()</code>你懂的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    InetAddress ia=InetAddress.getByName(<span class="string">"xxxx.net"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[]data=<span class="string">"This is a test"</span>;</span><br><span class="line">    <span class="keyword">int</span> port=<span class="number">4396</span>;</span><br><span class="line">    DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data,data.length,ia,port);</span><br><span class="line">    MulticastSocket ms=<span class="keyword">new</span> MulticastSocket()</span><br><span class="line">     <span class="comment">//MulticastSocket 可以不加入组就能向该组发送组播数据</span></span><br><span class="line">    ms.setTimeToLive(<span class="number">64</span>);</span><br><span class="line">    ms.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回送模式</p>
<p>你发出去的组播包，是否希望发回来，这个其实取决于平台支不支持，但你可以表达你自己的意愿</p>
<p><code>set/getLoopbackMode(boolean disabled)</code> true表示不希望获得自己发送的包,但不要保证一定如你所愿。你自己应该要做准备</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Java网络编程(十)安全Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Java网络编程(十)安全Socket/" itemprop="url">Java网络编程(十)安全Socket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>创建安全的socket其实很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketFactory factory=SSLSocketFactory.getDefault();</span><br><span class="line">Socket socket=factory.createSocket(<span class="string">"xxxx.org"</span>,<span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<p>createSocket有多个子方法</p>
<p> host port InetAddress  这三个为参数随机组合</p>
<p><code>Socket createSocket(Socket proxy,String host,int port,boolean autoClose)</code></p>
<p>它以一个连接到代理服务器的现有Socket对象为起点，这个方法返回一个经该代理服务器到指定主机和端口的socket  autoclose表示当这个socket关闭时，底层的socket是否关闭</p>
<p>实际上createSocket返回的时 SSLSocket，然后获得的socket就正常使用即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SSLSocketFactory factory=(SSLSocketFactory)SSLSocketFactory.getDefault();</span><br><span class="line">SSLSocket socket=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">socket=factory.createSocket(host,port);</span><br><span class="line">String[]supported=socket.getSupportedCipherSuites(); <span class="comment">//获取密码组，不一定全都可以在连接上用可能太弱</span></span><br><span class="line"><span class="comment">//getEnabledCipherSuites()</span></span><br><span class="line">socket.setEnableCipherSuites(supported); <span class="comment">//设置可使用的密码组</span></span><br></pre></td></tr></table></figure>
<p>密码组的算法 分四个部分 协议 密钥交换算法 加密算法 校验和</p>
<p>一般避免名字包含NULL ANON EXPORT 的密码组</p>
<p>TLS_ECDHE_WITH_AES_128_CBC_SHA256 是最强密码</p>
<p>TLS_ECDHE开头 SHA256/384 的密码组都很强</p>
<p>由于SSL导致网络通信很慢，这时候往往要进行异步处理，握手完成必须进行通知，只要实现</p>
<p>HandshakeCompletedListener接口</p>
<p>实现这个接口需要实现方法<code>void handshakeCompleted(HandshakeCompletedEvent)</code></p>
<p>HandshakeCompletedEvent提供了一一些获取信息的方法</p>
<ul>
<li>SSLSession getSession()</li>
<li>String getCipherSuite()</li>
<li>getPeerCertificateChain()</li>
<li>SSLSocket getSocket()</li>
</ul>
<p>通过add/remove HandshakeCompletedListener()可以对某个SSLSocket的握手事件进行关注</p>
<p>由于交换密钥等操作，带SSL的握手需要大量事件，倘若对一个主机的一个端口打开多个安全Socket 这时候JSSE 会自动重用这个会话的密钥</p>
<p>会话用SSLSocket表示</p>
<p>有多个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[]getID()</span><br><span class="line">   <span class="function">SSLSessionContext <span class="title">getSessionContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCreationTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastAccessedTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putValue</span><span class="params">(String name,Object value)</span></span></span><br><span class="line"><span class="function">Object <span class="title">getValue</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">getValueNames</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">getPeerCertificateChain</span><span class="params">()</span> <span class="title">getCipherSuite</span><span class="params">()</span> <span class="title">getPeerHost</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果不想开启多个socket的会话 <code>setEnableSessionCreation(boolean allowSessions)</code></p>
<p>可以通过<code>getEnableSessionCreation()</code>进行判断</p>
<p>如果想丢弃之前的证书和密钥，重新开启一个会话，可以用startHandshake()</p>
<h3 id="创建安全服务器socket"><a href="#创建安全服务器socket" class="headerlink" title="创建安全服务器socket"></a>创建安全服务器socket</h3><p>这需要SSLServerSocket </p>
<p>而首先需要SSLServerSocketFactory</p>
<ul>
<li>SSLServerSocketFactory xx=SSLServerSocketFactory.getDefault()</li>
<li>SSLServerSocket xxx =xx.createServerSocket(“xx”,3)</li>
<li>Socket a=xxx.accept()</li>
</ul>
<p>这时候a就是SSLSocket</p>
<p>但不要高兴太早，因为<code>getDefault</code>返回的工厂只支持服务器认证，不支持加密。为了加密需要更多设置  需要一个SSLContext去配置和初始花</p>
<p>步骤</p>
<ul>
<li>使用keytool生成公开密钥和证书</li>
<li>花钱认证你的证书</li>
<li>算法创建SSLContext</li>
<li>为证书源创建一个TrustManagerFactory</li>
<li>为密钥类型创建一个 KeyManagerFactory</li>
<li>为密钥和证书数据库创建一个KeyStore对象</li>
<li>用密钥和证书填充KeyStore</li>
<li>KeyManagerFactory TrustManagerFactory 随机源 来初始花上下文</li>
</ul>
<p>SSLServerSocket 的设置</p>
<p>其实它的很多设置方法和SSLSocket差不多，8过它针对的是服务器端的所有socket的默认设置进行设置</p>
<p>比如说设置密码组的一些操作</p>
<p>get/set Supported/Enabled CipherSuites</p>
<p>会话的控制</p>
<p>set/get EnableSessionCreation</p>
<p>set/get NeddClientAuth                  set/getUseClientMode() 设置客户端模式</p>
<p>客户端模式其实有点蛋疼</p>
<p>正常来说如果你服务器端你设置  setUseClientMode(true)你出错的，原因是设置后两边都是客户端，这样两边都打算主动发送handshake请求，这样无法做链接了。</p>
<p>解决办法让客户端那边变成服务器端 setUseClientMode(false) ，这样配合才行</p>
<p>效果是让原本客户端那边进行认证，而不是自己这边进行认证，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Java网络编程(十二)UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Java网络编程(十二)UDP/" itemprop="url">Java网络编程(十二)UDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UDP用两个类实现</p>
<p>DatagramPacket 和 DatagramSocket 将DatagramPacket类填充到UDP 这称为数据报</p>
<p>UDP没有两台主机唯一连接的概念，一个DatagramSocket可以从多个独立主机收发数据</p>
<p>UDP不需要知道谁发送数据，这个由程序保证。处理的不是流，总是单个单个数据包。而且你没法知道包的顺序</p>
<p>DatagramSocket实现了Autocloseable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dayTimeUdpClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">998</span>))&#123;</span><br><span class="line">			socket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">			InetAddress host=InetAddress.getByName(<span class="string">"time.nist.gov"</span>);</span><br><span class="line">			DatagramPacket request=<span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>],<span class="number">1</span>,host,<span class="number">13</span>);</span><br><span class="line">			DatagramPacket response=<span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">			socket.send(request);</span><br><span class="line">			socket.receive(response);</span><br><span class="line">			String result=<span class="keyword">new</span> String(response.getData(), <span class="number">0</span>, response.getLength(),<span class="string">"US-ASCII"</span>);</span><br><span class="line">			System.out.println(result);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UDPClient 整个通讯过程如下</p>
<ul>
<li>socket=new DatagramSocket(233)      233是你本机启用的端口号，随便找一个就行 0就是自动安排</li>
<li>socket.setSoTimeout(xx)   设置超时秒数，因为UDP发生错误是不会说的，所以如果设置超时能让你出错后从无限循环中跳出来</li>
<li>构建InetAddress</li>
<li>构建 DatagramPacket 表示接受 和发送端的数据包 要给byte数组  注意发送端，要给出host和port </li>
<li>socket.send(packet1)        socket.receive(packet2)</li>
<li>new String (response.getData,0,response.getLength(),”US-ASCII”) 将信息组成String</li>
</ul>
<p>UDP　Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">daytimeUdpServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">56</span>))&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">				DatagramPacket request=<span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">				socket.receive(request);</span><br><span class="line">				</span><br><span class="line">				String daytime=<span class="keyword">new</span> Date().toString();</span><br><span class="line">				<span class="keyword">byte</span>[]data =daytime.getBytes(<span class="string">"US-ASCII"</span>);</span><br><span class="line">				DatagramPacket response=<span class="keyword">new</span> DatagramPacket(data, data.length,request.getAddress(),request.getPort());</span><br><span class="line">				socket.send(response);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和client差不多，不过是要先receive再send</p>
<p>而且注意从 获取的DatagramPacket getAddress 和 getPort 确定远程主机的host和port   其实还有个getSocketAddress取获得一个SocketAddress</p>
<p>创建数据包 DatagramPacket</p>
<p>DatagramPacket类不能太大，不允许的，多的会被截取</p>
<p>最好8192以内</p>
<p>一般来说参数 就是</p>
<ul>
<li>byte[]  和长度       有些是给出  int  offset开始端</li>
<li>InetAddress  和 int  port 代表远程主机和端口        （用于发送数据的时候）</li>
</ul>
<p>注意offset和length  导致 data数组末尾还有未使用的空间是允许的，</p>
<p><strong>注意将byte数组 data传入DatagramPacket后 发送前还是能通过修改data数组 来改变将要发送的数据</strong></p>
<p>获取DatagramPacket后  一般通过 getBytes() 方法将byte数组变成能认识的string</p>
<p>但如果不包含文本</p>
<ol>
<li><code>InputStream in =new ByteArrayInputStream(packet.getData(),packet.getOffset(),packet.getLength())</code><ol start="2">
<li><code>DataInputStream din=new DataInputStream(in);</code><ol start="3">
<li>用 DataInputStream 的readInt readLong等方法获取数据</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>DatagramPacket还有 getData getLength getOffset</p>
<h3 id="各类Set方法"><a href="#各类Set方法" class="headerlink" title="各类Set方法"></a>各类Set方法</h3><p>除了构建函数创建DatagramPacket，还提供一些set方法 一般是用于重用DatagramPacket，因为构建一个还是比较要时间</p>
<p>public void setData(byte[]data) </p>
<p>改变UDP数据包的有效载荷，一般是用于如果需要发送更大的数据包的时候 需要更大的byte数组</p>
<p>public void setData(byte[]data,int offset,int length)   </p>
<p>这种方式是发送一个数组的部分 一般是用来byte数组太大，一次只发送一部分的数据 达到分包发送的效果          但是我感觉也没啥用，因为你比较难组合顺序，而且udp本身就不可靠</p>
<p>setAddress(InetAddress remote) </p>
<p>修改数据包将要发送的地址，达到同一个数据包发送多个不同的主机 但其实也没什么用，你可以用广播或组播去代替</p>
<p>setPort(int port)</p>
<p>更改监听的端口，改变数据包发送的端口（应该是远程主机的） 对应getPort嘛</p>
<p>setAddress(SocketAddress)   相当于remote 的host和port合集</p>
<p>setLength(int length)  改变内部缓冲区包含的实际数据包的字节数。这个很有用，</p>
<p>因为当接受到数据报的时候，其长度设置为入站数据的长度，如果试图正在同一个DatagramPacket中接受另一个数据报，那么会限制第二个的数据报的字节数不超过第一个的字节数，多的部分会被截取。 而setLength可以打破这个</p>
<h2 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h2><p>构造函数</p>
<p>DatagramSocket() 则将这个socket绑定到一个匿名的端口  绑定不了则抛出一个SocketException异常</p>
<p>DatagramSocket(int port)  注意TCP和UDP服务可以共用相同的端口</p>
<p>DatagramSocket(int port, InetAddress addr)  这个addr是用于匹配本机的某个网络接口的，不是远程主机的</p>
<p>DatagramSocket(SocketAddress )  和上面一个样，不过是以SocketAddress进行传递</p>
<p>DatagramSocket(DatagramSocketImpl impl)  impl是DatagramSocket的子类，提供自己的UDP实现 不过这种没有绑定端口，必须配套使用 bind(SocketAddress)</p>
<p>UDP的常用服务 RPC NFS TFTP FSP </p>
<p>send receive close 方法不用我多哔哔</p>
<p>getLocalPort()  getLocalAddress()  getLocalSocketAddress()  返回的是socket正在监听的端口，绑定的本地地址 返回了本地地址+端口</p>
<p>getPort()  getInetAddress()  getRemoteSocketAddress() 返回的是远程主机的东东</p>
<h3 id="管理连接"><a href="#管理连接" class="headerlink" title="管理连接"></a>管理连接</h3><p>虽然udp不是一对一的连接，但可以用connect来让它只监听某个特定的远程主机</p>
<p><code>void connect(InetAddress host, int port)</code> 并不真正建立连接，只是指定DatagramSocket只对指定的远程主机和指定的远程端口收发包。向其他主机或端口发送包会抛出异常，而来自其他主机或端口会全部丢弃</p>
<p><code>void disconnect()</code> 中断 “连接” ，注意是双引号的连接  这样就重新回到收发多个主机的情况</p>
<p>类似TCP   UDP 也有Socket选项</p>
<p>set/getSoTimeout()</p>
<p>set/getReceiveBufferSize()   set/getSendBufferSize()   set/getReuseAddress()  是否允许端口多用  </p>
<p>set/getBroadcast() 是否一个Socket向广播地址收发包  默认打开</p>
<p>set/getTrafficClass()  设置IP_TOS 设置包的类型，参数是一个二进制数不同二进制代表不同类型（0-255） </p>
<p>UDP也有Channel选项</p>
<p>UDP天生就比TCP多点异步性，但也有通道可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">SocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="number">3141</span>);</span><br><span class="line">DatagramSocket socket=channel.socket();</span><br><span class="line">socket.bind(address);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先创建通道</p>
</li>
<li><p>DatagramSocket 通过 通道获取</p>
</li>
<li>socket调用bind 绑定监听地址，就是本地的一个主机的地址（端口） 然后就不需要DatagranSocket了</li>
</ul>
<p>或者 直接channel.bind(Addr)即可</p>
<p>操作都由channel完成</p>
<p>Channel的两个方法</p>
<p><code>SocketAddress receive(ByteBuffer dst)</code></p>
<p>这里的receive是byte数组，挺神奇的。返回的是发送包的那个主机地址 如果通道是阻塞的，这方法会阻塞</p>
<p>非阻塞的时候没有包获取会返回null，这个    不建议，因为udp本来就不是稳定发送到为止，你这样可能会因为提前返回的原因就丢包并无法再获取了</p>
<p><code>int send(ByteBuffer src,SocketAddress target)</code> 返回的是写入的字节数</p>
<p>这个默认是阻塞，取决于通道本身是否阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个正常的一个channel的UDP服务器	</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			DatagramChannel channel=DatagramChannel.open();</span><br><span class="line">			DatagramSocket socket=channel.socket();</span><br><span class="line">			SocketAddress address=<span class="keyword">new</span> InetSocketAddress(PORT);</span><br><span class="line">			socket.bind(address);</span><br><span class="line">			ByteBuffer buffer=ByteBuffer.allocateDirect(MAX_PACKET_SIZE);</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//返回发送包的地址</span></span><br><span class="line">				SocketAddress client=channel.receive(buffer);</span><br><span class="line">				buffer.flip();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//发送前要 flip下buffer并提供地址</span></span><br><span class="line">				channel.send(buffer, client);</span><br><span class="line">				buffer.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>UDP通道其实也是你一个包我一个包，没有连接可言。</p>
<p>同样有个connect方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress remote=<span class="keyword">new</span> InetSocketAddress(<span class="string">"xxx"</span>,<span class="number">38</span>);</span><br><span class="line">channel.connect(remote);</span><br></pre></td></tr></table></figure>
<p>这时候这个通道只接收发送这个主机   其方法本身不会发送数据建立什么连接（因为是UDP），所以不会有阻塞</p>
<p><code>isConnected()</code>判断这个通道是否有连接</p>
<p>有 <code>disconnect()</code></p>
<p>connect的通道 可以使用 各种 <code>read()</code>方法</p>
<p>一般来说这个connect不适合服务器</p>
<p>DatagramChannel 有write()方法  可用于<strong>散布输出</strong></p>
<p>非阻塞通道可以用 selector那套东西处理。然后close可以通过 <code>isOpen()</code>判断</p>
<p>通道也支持UDP的Socket选项</p>
<p><code>set/getOption()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">defaultSocketOptionValues</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(DatagramChannel channel=DatagramChannel.open())&#123;</span><br><span class="line">			<span class="keyword">for</span>(SocketOption&lt;?&gt;option:channel.supportedOptions()) &#123;</span><br><span class="line">				System.out.println(option.name()+<span class="string">": "</span>+channel.getOption(option));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Java网络编程(七)URLConnection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Java网络编程(七)URLConnection/" itemprop="url">Java网络编程(七)URLConnection</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>URLConnection是一个抽象类，表示指向URL指定资源的活动连接。</p>
<p>用途</p>
<ul>
<li>URL类相比，它对服务器（Http服务器）的交互提供更多的控制 可以控制首部什么的，还能用几种请求方法</li>
<li>URLConnection 时协议处理器机制的一部分，这个机制还包括URLStreamHandler类</li>
</ul>
<p>协议处理器的思想</p>
<ol>
<li><p>将处理协议的细节和处理特定数据类型分开，提供相应的接口，并完成完整浏览器所完成的其他操作</p>
</li>
<li><p>URLConnection 是抽象类，要实现一个特定的协议就要编写一个子类。不同的协议就用不同的处理器去处理</p>
</li>
</ol>
<p>注：java.net 只有URLConnection抽象类，但除了<strong>connect()</strong>之外其他方法都实现了。它的具体子类放在sun.net中 URLConnection许多方法和字段和一个构造函数是protected的</p>
<p>虽然说能用来处理不同协议，不过URIConnection和http绑定过于紧密</p>
<p>使用URLConnection的步骤</p>
<ul>
<li>构造URL对象</li>
<li>URL对象的方法openConnection() 获取对象的URLConnection()</li>
<li>配置这个URLConnection</li>
<li>读取首部</li>
<li>获得输入流并读取数据 getInputStream()</li>
<li>获得输出流并写入数据</li>
<li>关闭连接</li>
</ul>
<p>URLConnection的唯一一个构造方法是protected的</p>
<ol>
<li><p>所以如果除非是派生URLConnection的子类来处理URL（显式指明自己调用的类）</p>
</li>
<li><p>否则都要调用URL类的openConnection()来构造对象 （我觉得这个对象是URLConnection的一个实现子类）</p>
</li>
</ol>
<p>从上知道 如果要实现URLConnection的子类 要实现的方法主要是<code>connect()</code>方法</p>
<p>connect的作用是在本地和远程主机之间建立一个连接，一般来说一些 getInputStream getContent等方法都会自动调用connect 所以你不需要显式调用它，只用实现</p>
<hr>
<h2 id="读取服务器的数据"><a href="#读取服务器的数据" class="headerlink" title="读取服务器的数据"></a>读取服务器的数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceViewer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                URL u=<span class="keyword">new</span> URL(args[<span class="number">0</span>]);</span><br><span class="line">                URLConnection uc=u.openConnection();  <span class="comment">//通过URL构造URLConnection</span></span><br><span class="line">                <span class="keyword">try</span>(InputStream raw=uc.getInputStream())&#123;</span><br><span class="line">                    InputStream buffer=<span class="keyword">new</span> BufferedInputStream(raw);  <span class="comment">//进行输入流包装</span></span><br><span class="line">                    Reader reader=<span class="keyword">new</span> InputStreamReader(buffer);  <span class="comment">//将输入流串联到阅读器</span></span><br><span class="line">                    <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span>((c=reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println((<span class="keyword">char</span>) c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(MalformedURLException ex)&#123;</span><br><span class="line">                    System.err.println(args[<span class="number">0</span>]+<span class="string">"is not a parseable URL"</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">                    System.err.println(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URLConnection 和URL的主要区别</p>
<ul>
<li>提供对首部的访问</li>
<li>配置发送给服务器的请求参数   可以更好地访问</li>
<li>可以向服务器写入数据</li>
</ul>
<h2 id="首部访问"><a href="#首部访问" class="headerlink" title="首部访问"></a>首部访问</h2><p>获取指定的首部字段</p>
<p>前6个方法可以请求首部中特定的常用字段</p>
<ul>
<li>Content-type        </li>
<li>Content-length     </li>
<li>Content-encoding</li>
<li>Date</li>
<li>Last-modified</li>
<li>Expires </li>
</ul>
<p>String getContentType()     text/plain  可能后面会加个charset等等 反正就是完整的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对改善字符编码有用</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceViewer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                URL u=<span class="keyword">new</span> URL(args[<span class="number">0</span>]);</span><br><span class="line">                URLConnection uc=u.openConnection();</span><br><span class="line">                <span class="comment">//获取contentType头部</span></span><br><span class="line">                String contentType=uc.getContentType();</span><br><span class="line">                String encoding=<span class="string">"ISO-8859-1"</span>;   <span class="comment">//默认编码风格</span></span><br><span class="line">                <span class="keyword">int</span> encodingStart=contentType.indexOf(<span class="string">"charset="</span>);</span><br><span class="line">                <span class="keyword">if</span>(encodingStart!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    encoding=contentType.substring(encodingStart+<span class="number">8</span>);  <span class="comment">//8是省略掉charset=</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>(InputStream raw=uc.getInputStream())&#123;</span><br><span class="line">                    InputStream buffer=<span class="keyword">new</span> BufferedInputStream(raw); </span><br><span class="line">                    Reader reader=<span class="keyword">new</span> InputStreamReader(buffer,encoding);  <span class="comment">//添加编码方式</span></span><br><span class="line">                    <span class="keyword">int</span> c;</span><br><span class="line">                    <span class="keyword">while</span>((c=reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println((<span class="keyword">char</span>) c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(MalformedURLException ex)&#123;</span><br><span class="line">                    System.err.println(args[<span class="number">0</span>]+<span class="string">"is not a parseable URL"</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">                    System.err.println(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int getContentLength() / long getContentLengthLong()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对读取二进制文件有用</span></span><br><span class="line">URLConnection uc=u.openConnection();    <span class="comment">//u是URL</span></span><br><span class="line">String contentType=uc.getContentType();</span><br><span class="line"><span class="keyword">int</span> contentLength=uc.getContentLength();</span><br><span class="line"><span class="keyword">if</span>(contentType.startWith(<span class="string">"text/"</span>)||contentLength==-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">throws</span> new <span class="title">IOException</span><span class="params">(<span class="string">"this not a binary file"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>(InputStream raw=uc.getInputStream())&#123;</span><br><span class="line">    InputStream in=BufferedInputStream(raw);</span><br><span class="line">    <span class="keyword">byte</span>[]data=<span class="keyword">new</span> <span class="keyword">byte</span>[contentLength];</span><br><span class="line">    <span class="keyword">int</span> offset=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(offset&lt;contentLength)&#123;</span><br><span class="line">        <span class="keyword">int</span> byteRead=in.read(data,offset,data.length-offset);</span><br><span class="line">        <span class="keyword">if</span>(byteRead==-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        offset+=byteRead;</span><br><span class="line">    &#125;</span><br><span class="line">    String filename=u.getFile();</span><br><span class="line">    filename=filename.substring(filename.lastIndexOf(<span class="string">'/'</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span>(FileOutputStream fout=<span class="keyword">new</span> FileOutputStream(filename))&#123;  <span class="comment">//通过名字创建一个文件输出流</span></span><br><span class="line">        fout.write(data);    <span class="comment">//将byte数组填入输出流中 然后刷新</span></span><br><span class="line">        fout.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String getContentEncoding()  指出内容如何编码，比如可能是x-gzip 这样可以用 GZipInputStream解码</p>
<p>ContentEncoding 内容编码和字符编码(ContentType)不同，字符编码有Content-Type/文档内部信息确定 指出如何将字符编码成字节 内容编码方式则指出字节如何编码为其他字节 用于加密和压缩的作用</p>
<p>long getDate()   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date documentSent=<span class="keyword">new</span> Date(uc.getDate());      <span class="comment">//没有指明则返回0</span></span><br></pre></td></tr></table></figure>
<p>long getExpiration() 指定Cookies过期的日期 如何没指明返回0 用法和上面一样</p>
<p>long getLastModified 返回文档最后修改日期 没有则返回0  用法同上  这个要用Date包装一下</p>
<p>其实上面各种方法都是有点小蛋疼</p>
<p>直接 uc.getHeaderField(“你想要的字段名”)   不区分大小写            返回的都是String  如果是时间之类的可以将其转为long 然后再构造Date</p>
<p>如果没有则会返回null</p>
<p>String getHeaderFieldKey(int )   （首部键值） String getHeaderField(int n)  （首部值）</p>
<p>返回第n个首部字段键或者是字段值   第一个首部的编号为1         感觉是拿来遍历的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">URL u=<span class="keyword">new</span> URL(xxx);</span><br><span class="line">URLConnection=u.openConnection();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line">    String header=uc.getHeaderField(i);</span><br><span class="line">    <span class="keyword">if</span>(header==<span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">    System.out.println(uc.getHeaderFieldKey(i)+<span class="string">":"</span>+header);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (MalformedURLException ex)&#123;</span><br><span class="line">    System.err.println(xxx+<span class="string">"is not a URL"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">    System.err.println(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>long getHeaderFieldDate(String name,long default)  针对 expires last-modified date 字段</p>
<p>int getHeaderFieldInt(String name,int default)  针对的是 content-length</p>
<hr>
<p>Expires 我们知道这是对文档的缓存时间（前面说cookie说错了） 实际上 Cache-control 提供细粒度的缓存策略</p>
<ul>
<li>max-age=[seconds]  过期之前的秒数</li>
<li>s-maxage=[seconds] 直到缓存项在共享缓存中过期之前的秒数，私有缓存可以将缓存项保存更长的时间</li>
<li>public 可以缓存一个经过认证的响应。否则已认证的响应不能缓存</li>
<li>private 仅单个用户缓存可以保存相应 共享缓存不应保存</li>
<li>no-cache 缓存项能缓存 但每次访问都要用一个Etag 或 Last-modified首部重新验证响应状态</li>
<li>no-store 不缓存</li>
</ul>
<p>Cache-control 覆盖Expires 多个Cache-control不冲突可同时存在</p>
<p>Last-modified指示资源上一次修改的日期，只有缓存时间比这个早才会真正指向GET获取资源</p>
<p>Etag 资源的唯一标识符，不同的资源Etag不同</p>
<p>Java默认情况下不完成缓存，要安装URL类使用的系统级缓存</p>
<ul>
<li>ResponseCache 的一个具体子类</li>
<li>CacheRequest 的一个具体子类</li>
<li>CacheResponse 的一个具体子类</li>
</ul>
<p>安装你的ResponseCahce 子类来处理你得CacheRequest 和 CacheResponse子类     需要将其传递到<strong>ResponseCache.setDefault() 这将缓存对象安装为系统的默认缓存</strong>，Java虚拟机支支持一个共享缓存</p>
<p>一旦安装了缓存，只要系统加载一个新URL 就会先从缓存中查找，如果有响应缓存就URLConnection不会和远程服务器连接，如果不在那就下载并将响应放入缓存</p>
<p>ResponseCache 提供两个抽象方法</p>
<p><code>CacheResponse get(URI uri,String requestMethod ,Map&lt;String,List&lt;String&gt;&gt; requestHeaders)throws IOException</code></p>
<p>从缓存中获取数据和首部，包装CacheResponse 对象中返回。如果所需URI不在缓存中，返回null        </p>
<p><code>CacheResquest put(URI uri,URLConnection conn)throws IOException</code></p>
<p>大概是设置缓存，然后返回一个包装了数据流的CacheResquest对象</p>
<p>CacheRequest 包装了一个OutputStream URL将把读取的可缓存数据写入这个输出流 它内部有两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheRequest要的实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRequest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> OutputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="comment">//返回一个输出流，指向缓存  输出流和缓存的存储方式密切相关 如果数据存储在一个文件中 则返回FileOutputStream</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果数据向输出流复制出现问题，这个方法应当从缓存删除为这个请求存储的所有数据</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>SimpleCacheRequest 类 只是你构造一个容器(用来保存缓存数据)而已，具体怎么存数据是ResponseCache 来处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleCacheRequest</span> <span class="keyword">extends</span> <span class="title">CacheRequest</span></span>&#123;</span><br><span class="line">    private ByteArrayOutputStream out=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    public OutputStream getBody()throws IOException&#123;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> abort()&#123;</span><br><span class="line">        out.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得具体数据</span></span><br><span class="line">    public byte[] getData()&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheResponse 要实现的方法  </span></span><br><span class="line"></span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt;getHeaders()<span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="function">InputStream <span class="title">getBody</span><span class="params">()</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>具体的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCacheResponse</span> <span class="keyword">extends</span> <span class="title">CacheResponse</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,List&lt;String&gt;&gt; headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleCacheRequest request;   <span class="comment">//他竟然要CacheRequest对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date expires;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheControl control;   <span class="comment">//CacheControl对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCacheResponse</span><span class="params">(SimpleCacheRequest request,URLConnection uc,CacheControl control)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request=request;</span><br><span class="line">        <span class="keyword">this</span>.control=control;</span><br><span class="line">        <span class="keyword">this</span>.expires=<span class="keyword">new</span> Date(uc.getExpiration());</span><br><span class="line">        <span class="keyword">this</span>.headers=Collections.unmodifiableMap(uc.getHeaderFields());  <span class="comment">//首部存储为键值对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(request.getData());  </span><br><span class="line">        <span class="comment">//通过CacheRequest对象来实现操作，说明CacheResponse还是要通过CacheRequest去指向Cache数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,List&lt;String&gt;&gt; getHeaders() <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheControl <span class="title">getControl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> control;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将CacheControl的东西也包在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Date now =<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">if</span>(control.getMaxAge().before(now)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(expires!=<span class="keyword">null</span>&amp;&amp; control.getMaxAge()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> expires.before(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>私有缓存，就是不能被各级代理缓存的缓存，只能本机进行缓存</p>
<p>ResponseCache子类 在请求时存储和获取缓存的之，同时注意Cache-control首部</p>
<p>我们知道要实现的主要就是 put 和 get两个方法</p>
<p>其实我觉得CacheResquest其实式为CacheResponse 服务的，真正存储是用CacheResponse 但真正去访问数据的是CacheResquest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">extends</span> <span class="title">ResponseCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;URI,SimpleCacheResponse&gt;responses=<span class="keyword">new</span> ConcurrentHashMap&lt;URI,SimpleCacheResponse&gt;;</span><br><span class="line">    <span class="comment">//真正将URI和缓存对应的东东，缓存方式CacheResponse</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxEntries;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCache</span><span class="params">(<span class="keyword">int</span> maxentries)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxEntries=maxentries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheRequest <span class="title">put</span><span class="params">(URI uri,URLConnection conn)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(responses.size()&gt;=maxEntries)<span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//超过最大的缓存设置了</span></span><br><span class="line">        <span class="comment">//通过URLConnection的首部获取缓存方案</span></span><br><span class="line">        CacheControl control=<span class="keyword">new</span> CacheControl(conn.getHeaderField(<span class="string">"Cache-Control"</span>));</span><br><span class="line">        <span class="keyword">if</span>(control.noStore())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!conn.getHeaderField(<span class="number">0</span>).startsWith(<span class="string">"GET"</span>))&#123;</span><br><span class="line">            <span class="comment">//加这个判断只是因为这个缓存只是要缓存get方法的东东</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleCacheRequest request=<span class="keyword">new</span> SimpleCacheRequest();</span><br><span class="line">        SimpleCacheResponse response=<span class="keyword">new</span> SimpleCacheResponse(request,conn,control);</span><br><span class="line">        responses.put(uri,response);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheResponse <span class="title">get</span><span class="params">(URI uri,String requestMethod,Map&lt;String,List&lt;String&gt;&gt;requestHeaders)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"GET"</span>.equals(requestMethod))&#123;</span><br><span class="line">            SimpleCacheResponse response=response.get(uri);</span><br><span class="line">            <span class="keyword">if</span>(response!=<span class="keyword">null</span>&amp;&amp;response.isExpired())&#123;</span><br><span class="line">                responses.remove(response);</span><br><span class="line">                response=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> reponse;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java要求一次只有一个url缓存 要安装或改变缓存，需要使用静态方法ResponseCache.setDefault()和ResponseCache.getDefault()   这两个方法会设置同一个java虚拟级中运行所有程序中所使用的缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置缓存类？</span></span><br><span class="line">ResponseCache.setDefault(<span class="keyword">new</span> MemoryCache());  <span class="comment">//urlconnections会一直使用这个缓存</span></span><br></pre></td></tr></table></figure>
<p>之后获取的资源，如果作为缓存则保留在hashmap之中，直到过期。在上面的ResponseCache的实现类中，它是在过期后再次请求资源的时候才会将其移除缓存中并返回null，除了这样做之外，可以用一个低优先级的线程扫描文档将其删除，或者将所有资源按时间顺序缓存在一个队列中，必要时删除过期或最接近过期的资源，腾出空间。更复杂的可以加上访问频率，删除最老和最少使用资源。</p>
<p>但其实还有别的方式  1.在文件系统上实现 2.缓存在数据库中 3.将某些url请求重定向到本地服务器中 或者加载某一组特定的固定文件，然后在内存中提供这些文件（处理很多不同的soap请求服务器很有用）</p>
<p>URLConnection类 有保护实例字段，定义客户端对服务器的请求  并不是http的首部 懂8小老弟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URL url</span><br><span class="line"><span class="keyword">boolean</span> doInput =<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> doOutput=<span class="keyword">false</span>;             <span class="comment">//如果true 除了通过这个URLConnection 读数据也可以将数据写入服务器</span></span><br><span class="line"><span class="keyword">boolean</span> allowUserInteraction=defaultAllowUserInteraction;</span><br><span class="line"><span class="keyword">boolean</span> useCaches=defaultUseCaches;    <span class="comment">//如果为false 则绕过本地缓存向服务器下载</span></span><br><span class="line"><span class="keyword">long</span> ifModifiedSince=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> connected=<span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>控制上面的字段除了connected 和 url (它是在构造URLConnection是决定的  只有 getURL() )</p>
<p>其他字段对应一个set和get方法      比如 <code>boolean getDoInput()</code> 和<code>void setDoInput(boolean doInput)</code></p>
<p>还有一些还有一些方法设置URLConnection的默认行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get/setDefaultUseCaches()</span><br><span class="line">get/setDefaultAllowUserInteraction()</span><br><span class="line">get/setFileNameMap()</span><br><span class="line">当然set方法是需要参数的第三个是FileNameMap 前两个为<span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>
<p>boolean connected</p>
<p>如果连接已经打开则为true 否则为false 如果创建新URLConnection对象时连接未打开 也为false </p>
<p>没有直接获取或改变connected的方法  但任何导致URLConnection连接的方法都会设置该变量为true </p>
<ul>
<li>connect()</li>
<li>getInputStream()</li>
<li>getOutputStream()</li>
</ul>
<p>任何导致URLConnection断开连接的方法都会把该字段设置为false   URLConnection中没有<code>disconnect()</code></p>
<p>但它的一些子类如 HttpURLConnection有</p>
<p>如果你是要自己派生实现URLConnection子类 你就要在连接和关闭时改变connected变量 java.net.URLConnection中许多方法都会读取这变量，来确定操作，如果未设置就会出很多难判断的bug</p>
<p>boolean allowUserInteraction</p>
<p>是否能和用户进行交互   比如会询问用户名和口令 神魔的，但有时候很多应用程序不能假定有真实存在的用户，比如只是一个小机器人</p>
<p>会有一些身份认证？</p>
<p>不懂   </p>
<p>boolean doInput 是否可读取 服务器 </p>
<p>boolean doOutput 默认为false</p>
<p>程序可以用URLConnection将输出发回服务器写入服务器</p>
<p>当doOutput设置true 这时候请求方法就从get变成post</p>
<p>boolean ifModifiedSince</p>
<p>客户端可能会缓存来自服务器的资源，但可能这个资源会在服务器中已经改变了，这时候就要更新缓存，就要询问服务器  在http首部中包括一个 if-modified-since 这个首部包括一个日期和时间  如果在这个时间后有修改服务器就发送该文档，否则不发回复一个304 未修改消息</p>
<p>但有些web服务器不会理会if-modified-since这个字段 都会发送</p>
<p>ifmodifiedsince 用的时格林尼治标准时间1970.1.1子夜后的毫秒数 所有参数时一个long</p>
<p>boolean useCaches 获取是否使用本地的缓存资源，而不是从服务器中获取</p>
<p><code>uc.setUseCaches(true);</code></p>
<p>超时</p>
<p>其实还有两个属性是定义超时  ConnectionTimeout / ReadTimeout 都有相应的get/set方法  参数都是int</p>
<p>毫秒为单位 设置为0 则永不超时 设置为负数则为抛出异常 </p>
<p>ConnectionTimeout  代表控制socket等待建立连接的时间  (ms单位)</p>
<p><code>uc.setConnectionTimeout(3000)</code></p>
<p>ReadTimeout  代表输入流的等待时间 （ms单位）</p>
<p><code>uc.setReadTimeout(6000)</code></p>
<p>配置客户端发送的http首部</p>
<p>setRequestProperty(String name,String value)   getRequestProperty(String name)</p>
<p>键值对  多个属性的话用逗号分隔</p>
<p>注意这些只用于http协议中  如果其他协议会有其他意思 （指的是键值对还是方法有其他意思？应该是前者巴巴吧）</p>
<p>对于Cookie值 则是键值对之间分号分隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uc.setRequestProperty(<span class="string">"Cookie"</span>,<span class="string">"username=elharo;password=xxxx"</span>);</span><br><span class="line"><span class="comment">//可以对一个属性设置多次值，不过这会覆盖</span></span><br><span class="line"><span class="comment">//如果是想要在原有基础上添加</span></span><br><span class="line">uc.addRequestProperty(<span class="string">"Cookie"</span>,<span class="string">"..."</span>);</span><br><span class="line"><span class="comment">//添加是在一开始加，所以如果是cookie是要加分号，不是cookie则不要加</span></span><br></pre></td></tr></table></figure>
<p>查看首部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getRequestProperty</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Map&lt;String,List&lt;String&gt;&gt;<span class="title">getRequestProperties</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>用DoOutput向服务器进行写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL u=<span class="keyword">new</span> URL(<span class="string">"http://xxx"</span>);</span><br><span class="line">URLConnection uc=u.openConnection();</span><br><span class="line">uc.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">OutputStream raw=uc.getOutputStream();</span><br><span class="line">OutputStream buffered=<span class="keyword">new</span> BufferedOutputStream(raw);</span><br><span class="line">OutputStreamWriter out=<span class="keyword">new</span> OutputStreamWriter(buffered,<span class="string">"8859_1"</span>);</span><br><span class="line">out.write(<span class="string">"username=aab;password=12315"</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormPoster</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> QueryString query=<span class="keyword">new</span> QueryString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FormPoster</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!url.getProtocol().toLowerCase().startsWith(<span class="string">"http"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Posting only works for http URLs"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url=url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name,String value)</span></span>&#123;</span><br><span class="line">        query.add(name,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getURL</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">post</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        URLConnection uc=url.openConnection();</span><br><span class="line">        uc.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//带资源的try 自动关闭out  不关闭out 不会发送数据</span></span><br><span class="line">        <span class="keyword">try</span>(OutputStreamWriter out=<span class="keyword">new</span> OutputStreamWriter(uc.getOutputStream(),<span class="string">"UTF-8"</span>))&#123;</span><br><span class="line">            <span class="comment">//发送post的数据</span></span><br><span class="line">            out.write(query.toString());</span><br><span class="line">            out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uc.getInputStream();<span class="comment">//获取读取流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        URL url;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            url=<span class="keyword">new</span> URL(args[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(MalformedURLException ex)&#123;</span><br><span class="line">                System.err.println(<span class="string">"Usage:java FormPoster url"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       FormPoster poster=<span class="keyword">new</span> FormPoster(url);</span><br><span class="line">        poster.add(<span class="string">"name"</span>,<span class="string">"xxxx"</span>);</span><br><span class="line">        poster.add(<span class="string">"password"</span>,<span class="string">"123"</span>);</span><br><span class="line">        <span class="keyword">try</span>(InputStream in=poster.post())&#123;</span><br><span class="line">            <span class="comment">//读取响应 是一个html</span></span><br><span class="line">            Reader r=<span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">            <span class="keyword">int</span> c ;</span><br><span class="line">            <span class="keyword">while</span>((c=r.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123; System.err.println(ex);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QueryString 是干嘛的？？？？？？？？？？？？？？？？？？/</p>
<p>是自己实现地一个类</p>
<p>getOutputStream 方法可以用于put请求方法，这是一种在web服务器存储文件的方法，要存储的数据写入到getOutputStream 返回的OutputStream 不过这只能 在URLConnection 的HttpURLConnection 子类中进行</p>
<p>为了安全有个  <code>Permission getPermission() throws IOException</code> 返回一个Permission对象，指出这个连接的URL权限</p>
<p>推测MIME媒体类型，由于一些服务器不提供MIME首部，或者提供不正确首部，所以有时候需要推测正确的MIME媒体类型</p>
<p>两个URLConnection方法</p>
<p><code>public static String guessContentTypeFromName(String name)</code> 根据资源的拓展名进行推测 </p>
<p>但对RDF XSL CSS等未提供正确的MIME</p>
<p><code>public static String guessContentTypeFromStream(InputStream in)</code> 尝试查看流中前几个字节来猜测内容类型。这个InputStream一定要支持标记，从而读取了前面的字节之后可以返回到流的开始处。不一定可靠，</p>
<p>HttpURLConnection</p>
<p>是URLConnection的抽象子类，提供了更多的方法用来处理http URL ，但这是抽象子类，唯一的构造函数是保护类型，但如果使用http URL 构造一个URL对象并调用openConnection()方法，返回的就是HttpURLConnection一个实例，这时候可以强制转换</p>
<p><code>URL u=new URL(&quot;http://www&quot;);</code></p>
<p><code>URLConnection uc=u.openConnection();</code></p>
<p><code>HttpURLConnection http=(HttpURLConnection)uc;</code></p>
<p>HttpURLConnection可以设置请求方法</p>
<p><code>public void setRequestMethod(String method)</code></p>
<p>get/post/head/put/delete/options/trace  其他方法还会抛出 ProtocolException异常 这是IOException的一个子类</p>
<p>然而只设置方法是不够的，还要操作，http首部，消息体都要搭配上</p>
<p>其他的一些拓展方法 WebDAV 的一些方法 Java 不支持</p>
<p>主动断开与服务器的连接</p>
<p>如果使用keep-alive时，服务器不会因为已经向客户端发送最后一个字节的数据就立即关闭连接，会等待一段时间，让连接超时关闭。</p>
<p>httpurlconnection可以显式使用disconnnect()方法显式断开连接  如果连接上有流，它也会处理关闭这些流。</p>
<p>但你要知道关闭持久连接上的流，不代表这个socket断开</p>
<p>获取首部行</p>
<p><code>uc.getResponseCode()</code> 获取首部的响应代码</p>
<p><code>uc.getResponseMessage()</code> 获取首部响应代码的解释内容</p>
<p>其实还不如 <code>uc.getHeaderField(0)</code></p>
<p>错误条件</p>
<p>当页面出错的时候，同样会返回有用的信息，这时候需要</p>
<p><code>InputStream getErrorStream</code>去返回错误的信息流</p>
<p>其他用法就想普通的输入流差不多</p>
<p>重定向</p>
<p><code>static boolean getFollowRedirects()</code>  是否重定向</p>
<p><code>static void setFollowRedirects(boolean follow)</code> 设置是否跟随</p>
<p>注意set的是static方法，所以它会影响之后所有的urlconnection是否跟随重定向，其实我觉得跟随重定向很正常吧。。</p>
<p>如果只是针对实例配置</p>
<p><code>boolean getInstanceFollowRedirects()</code></p>
<p><code>void setInstanceFollowRedirects(boolean followRedirects)</code></p>
<p>查看代理</p>
<p>查看你某个HttpURLConnection是否通过某个代理对象</p>
<p><code>boolean usingProxy()</code></p>
<p>流模式</p>
<p>有三种</p>
<ul>
<li>一个是缓存输出后</li>
<li><code>setFixedLengthStreamingMode(long)</code> 设置文件长度 到时就直接进行传输，不过传的参数一定要对</li>
<li><code>setChunkedStreamingMode(int chunkLength)</code> 设置分块传输的大小，注意DoOutput要设置true</li>
</ul>
<p>上面三个不能同时用，比如2.3方法不能同时用，否则出错</p>
<p>而且用2.3种对于身份认证和重定向没有什么智商，需要你自己手工完成解决 比如一个合适的url 一般没有必要不要改流模式</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen JianLun</p>
              <p class="site-description motion-element" itemprop="description">Embrace the trend</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen JianLun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
