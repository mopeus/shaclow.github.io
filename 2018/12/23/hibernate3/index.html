<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="深入理解Hibernate映射 @Entity 被该注释修饰的POJO就是一个实体，里面有属性如下  name 指定实体类的名称，如果没有指定自动用类名作为实体类的名称  @Table 指定持久化类映射的表  name指定所映射表的表明，如果没指定就默认和持久化类的类名相同 index为持久化类所映射的表建立索引，该属性的值是一个@Index注解的数组  @UniqueConstraint 用于为">
<meta property="og:type" content="article">
<meta property="og:title" content="hibernate3">
<meta property="og:url" content="http://yoursite.com/2018/12/23/hibernate3/index.html">
<meta property="og:site_name" content="Shaclow&#39;s Blog">
<meta property="og:description" content="深入理解Hibernate映射 @Entity 被该注释修饰的POJO就是一个实体，里面有属性如下  name 指定实体类的名称，如果没有指定自动用类名作为实体类的名称  @Table 指定持久化类映射的表  name指定所映射表的表明，如果没指定就默认和持久化类的类名相同 index为持久化类所映射的表建立索引，该属性的值是一个@Index注解的数组  @UniqueConstraint 用于为">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-22T16:53:04.515Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hibernate3">
<meta name="twitter:description" content="深入理解Hibernate映射 @Entity 被该注释修饰的POJO就是一个实体，里面有属性如下  name 指定实体类的名称，如果没有指定自动用类名作为实体类的名称  @Table 指定持久化类映射的表  name指定所映射表的表明，如果没指定就默认和持久化类的类名相同 index为持久化类所映射的表建立索引，该属性的值是一个@Index注解的数组  @UniqueConstraint 用于为">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/23/hibernate3/"/>





  <title>hibernate3 | Shaclow's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shaclow's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello,my world.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/hibernate3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen JianLun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaclow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">hibernate3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:52:49+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>深入理解Hibernate映射</p>
<p>@Entity 被该注释修饰的POJO就是一个实体，里面有属性如下</p>
<ul>
<li>name 指定实体类的名称，如果没有指定自动用类名作为实体类的名称</li>
</ul>
<p>@Table 指定持久化类映射的表</p>
<ul>
<li>name指定所映射表的表明，如果没指定就默认和持久化类的类名相同</li>
<li>index为持久化类所映射的表建立索引，该属性的值是一个@Index注解的数组</li>
</ul>
<p>@UniqueConstraint 用于为数据表定义唯一约束</p>
<ul>
<li>columnNames 该属性值一个字符串数组，每个字符串代表一个数据列</li>
</ul>
<p>唯一约束保证在一个字段或者一组字段（感觉是将一组字段是当作一个整体来比较）里的数据与表中其它行的数据相比是唯一的</p>
<p>@Index 用于数据表定义索引</p>
<ul>
<li>columnList 设置对哪些列建立索引，该属性值课指定多个数据列的列名</li>
<li>name 索引的名字</li>
<li>unique 该索引是否具有唯一性</li>
</ul>
<p>@Access 用于修改属性访问策略</p>
<ul>
<li><p>value值 AccessType.PROPERTY(默认) AccessType.FIELD 两个值</p>
<p>PROPERTY要使用set/get去访问属性值，FIELD则直接通过成员变量来访问属性（一般不建议）</p>
</li>
</ul>
<p>@Proxy 该注解的proxyClass属性指定一个接口，在延迟加载时作为代理使用，也可以在这里指定该类自己的名字</p>
<p>@DynamicInsert 指定insert语句是否在运行时动态生成，并只插入非空的字段，默认为false,因为这会降低性能</p>
<p>@DynamicUpdate 和上面差不多 可以指定乐观锁</p>
<p>@OptimisticLockType 乐观锁</p>
<ul>
<li>VERSION 检查version/timestamp字段   （推荐）</li>
<li>ALL 检查全部字段</li>
<li>DIRTY 只检查修改过的字段</li>
<li>NONE 不使用乐观锁定</li>
</ul>
<p>@SelectBeforeUpdate 指定Hibernate在update某个持久化对象前是否进行一次查询。如果该注解的value值设为true，则可以保证只有持久化对象状态被修改过才会update，若相同则不会update</p>
<p>@PolymorphismType 隐式多态循环¿</p>
<p>@Where </p>
<ul>
<li>clause 指定一个附加的SQL语句过滤条件(类似添加where子句)如果指定该注解，则不管采用load()/get()或其他查询方法，只要加载持久化类的对象时，这个where条件才生效，只有符合条件的记录才会被加载</li>
</ul>
<p>@BatchSize Hibernate抓取集合属性或延迟加载的实体，该注解的size属性指定每批抓取的实例数</p>
<p>@Check 可通过constraints属性制定一个sql表达，用于为该持久化类所对应的表指定一个check约束</p>
<p>@Subselect 该注解用于映射不可变、只读实体</p>
<h3 id="数据库映射"><a href="#数据库映射" class="headerlink" title="数据库映射"></a>数据库映射</h3><p>@Column 代表映射的具体的列</p>
<p>@Formula 该注解的value属性可以指定一个sql表达式 指定该属性值是由这个这个表达式计算的  该属性是动态计算的，<strong>不保存在数据库</strong></p>
<ol>
<li>表达式要加括号 </li>
<li>括号中的是SQL表达式，里面的列名和表名和数据库对应，不和持久化对象属性对应  可以用数据库内置的函数　</li>
<li>不过可以将属性作为参数传入到where这种东西里</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Formula</span>(<span class="string">"(select concat(nt.title,nt.content) from news_inf nt where nt.id=id)"</span>)</span><br><span class="line"><span class="keyword">private</span> String fullContent;                                              <span class="comment">//id是对象属性值</span></span><br></pre></td></tr></table></figure>
<p>我们可以从上述的代码可以看出这个fullcontent虽然是从数据库获取信息，但其实是在java代码中写好的。如果是要直接在数据库中生成数据，则可以用@Generated</p>
<p>@Generated 每当hibernate中执行一条insert(@Generated value是INSERT或者ALWAYS)或是update (@Generated value是ALWAYS) hibernante会执行一条select语句去获得该数据列的值并赋给实例对象的属性，而这个值实在数据库运算得出的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String content;</span><br><span class="line"><span class="meta">@Generated</span>(GenerationTime.ALWAYS)</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"full_content"</span>)</span><br><span class="line"><span class="keyword">private</span> String fullContent;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> news_in(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">content</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    full_content <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"># 创建触发器</span><br><span class="line">DELIMITER |</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t_full_content_gen <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> news_inf</span><br><span class="line">	<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">set</span> new.full_content=<span class="keyword">concat</span>(new.title,new.content);</span><br><span class="line">	<span class="keyword">END</span>;</span><br><span class="line">|</span><br><span class="line">DELMITER;</span><br></pre></td></tr></table></figure>
<p>数据库中在MySQL中用<code>old</code>和<code>new</code>表示执行前和执行后的数据</p>
<p>在对new赋值的时候只能在触发器before中用 ，在after的触发器中，new的赋值已经结束了，只能读取内容。 如果使用after不能使用new赋值，只能取值，否则会出错误</p>
<p>old在用于取值？因为赋值没意义？</p>
<p>DELIMITER 的作用 设置结束符         比如DELIMITER | 则设置结束符为 |</p>
<p>告诉mysql解释器，当看到 |  的时候该段命令已经结束了，mysql可以执行了。默认情况下，delimiter是分号 ;</p>
<p>所以最后要 DELIMITER ; 将其结束符改回来</p>
<p>这样就在数据插入的时候触发触发器生成full_content列的数据，将其插入数据库中</p>
<p>但是咧，一定要实例化对象是保存在会话的时候才会进行数据库插入进行触发计算，所以如果在保存会话前取full_content是没有值的</p>
<p>@Transient 修饰不想持久保存的属性</p>
<p>默认情况下持久化类的属性都会映射到数据表中数据列，如果不想持久保存一些属性，可以用@Transient修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure>
<p>感觉这个和@Formula的区别是这个的数据不是自动生成的，可能需要对象某种方法赋值什么的</p>
<p>@Enumerated 修饰枚举类型的属性</p>
<p>这里的属性要是枚举类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Fruit&#123;</span><br><span class="line">    apple,banana,orange,grape</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于枚举来说，apple的枚举值可以用名称代表，也可用枚举值的序号0代表，同样底层数据库可以保存名字或者序号</p>
<p>EnumType.STRING 底层数据库保存枚举值的名称 EnumType.ORDINAL 保存的是枚举值的数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Enumerated</span> (EnumType.ORDINAL)</span><br><span class="line"><span class="meta">@Column</span> (name=<span class="string">"smallfruit"</span>)   <span class="comment">//保存数字</span></span><br><span class="line"><span class="keyword">private</span> Fruit aa;</span><br></pre></td></tr></table></figure>
<p>@Lob @Basic</p>
<p>@Lob 可以表示两种类型分别为数据库保存图片和文本</p>
<p>@Lob修饰的属性是 byte[] Byte[] java.io.Serializable时，它们会被映射成Blob类型，用于保存图片</p>
<p>@Lob修饰的属性是 char[] Character[] java.lang.String 他们会映射成Clob列 用来保存长文本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存图片</span></span><br><span class="line">File file=<span class="keyword">new</span> File(<span class="string">"aab.jpg"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] content=<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)file.length()];</span><br><span class="line"><span class="keyword">new</span> FileInputStream(file).read(content);       <span class="comment">//创建文件读入流将文件读入content数组中</span></span><br><span class="line">person.setPic(content);          <span class="comment">//存储在持久化对象的@lob修饰的byte数组</span></span><br><span class="line">sess.save(person);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>但实际上@Lob通常会配一个@Basic 因为这种大数据量的东西，如果每次都加载而不需要的话就会造成性能的极大损耗，所以采取<strong>延迟加载</strong>，只有真正需要该属性时才从数据库加载。</p>
<p>@Basic</p>
<ul>
<li>fetch 接收 FetchType.EAGER/LAZY 前者立即加载后者延时加载</li>
<li>optional 属性映射的数据列是否允许null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="meta">@Basic</span> (fetch=FetchType.LAZY)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] pic;</span><br></pre></td></tr></table></figure>
<p>@Temporal 修饰日期</p>
<p>对于日期，java基本上使用Date，但数据库有很多类型date time timestamp等</p>
<p>属性value支持 TemporalType.DATE/TIME/TIMESTAMP</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Temporal</span>(TemporalType.DATE)</span><br><span class="line"><span class="keyword">private</span> Date bbb;</span><br></pre></td></tr></table></figure>
<p>所以会出现数据截取的情况，比如TemporalType.DATE 只取日期的部分 TIME只取时间的部分</p>
<p>映射主键</p>
<p>建议为持久化类定义一个标识属性，这就是底层数据库中的主键</p>
<p>现代数据库建模理论都推荐 不要使用物理主键（甚至是联合主键）（带语义的列） 而是使用逻辑主键 则建立外键列则方便很多，主从表的约束关系清晰</p>
<p>根据之前的经验，我们是用@Id去修饰该实体的属性</p>
<p>由于逻辑主键没有意义，所以Hibernate可以为这种主键提供主键生成器，负责为每个持久化实例生成唯一的逻辑主键值，我们是使用@GeneratedValue</p>
<p>@GeneratedValue</p>
<ul>
<li>strategy <ul>
<li>GenerationType.AUTO 自动选择最适合底层数据库的主键生成策略 默认</li>
<li>GenerationType.IDENTITY 对mysql,sqlserver 选择自增长的主键生成策略</li>
<li>GenerationType.SEQUENCE 对于oracle数据库，选择基于sequence主键生成策略 （和@SequenceGenerator使用）</li>
<li>GenerationType.TABLE 使用辅助表来生成主键 和@TableGenerator配合使用</li>
</ul>
</li>
<li></li>
<li>generator GenerationType.SEQUENCE和GenerationType.TABLE 该属性引用@SequenceGenerator @TableGenerator所定义的生成器的名称</li>
</ul>
<p>@SequenceGenerator 定义生成器的配置</p>
<ul>
<li>name 主键生成器的名称</li>
<li>catalog schema 将底层的sequence放入指定catalog schema中</li>
<li>initialValue 指定Sequence的初始值</li>
<li>sequenceName 指定列的名称</li>
</ul>
<p>@TableGenerator 定义的主键生成器会在底层数据库中额外生成一个辅助表</p>
<ul>
<li>name</li>
<li>catalog schema</li>
<li>table 指定表名</li>
<li>pkColumnName 指定存放主键名</li>
<li>valueColumnName 指定主键值的列名</li>
<li>indexes 该属性值的是一个@Index数组，用于辅助表定义索引</li>
<li>uniqueConstraints 属性值@UniqueConstraint数组，用于为辅助表创建唯一约束</li>
</ul>
<p>反正这两个Generator定义了一个生成器后这个name要给到@GeneratedValue 注解的generator属性值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@TableGenerator</span>(name=<span class="string">"newsGen"</span>,table=<span class="string">"newidgen"</span>,pkColumnName=<span class="string">"gen_key"</span>, valueColumnName=<span class="string">"gen_value"</span>, pkColumnValue=<span class="string">"news_id"</span>)</span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy=GenerationType.TABLE,generator=<span class="string">"newsGen"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br></pre></td></tr></table></figure>
<p>创建了一个新表 newidgen 里面有两列 分别是两行gen_key gen_value  有一行gen_key的值为 news_id gen_value是自动生成的1</p>
<p>其实Sequence和Table主键生成器虽然允许你做一些配置，但实际上是已经是固定好生成器策略了，但实际上Hibernate还能支持其他的生成器和策略  </p>
<p>如果需要，则使用Hibernate 提供的@GenericGenerator       其实就是把其他别的统一定义为@GenericGenerator</p>
<ul>
<li>name 主键生成器名称</li>
<li>strategy 主键生成器的主键生成策略</li>
</ul>
<p>strategy 属性可以是自定义的主键生成类（需要实现Hibernate的IdentifierGenerator接口），也可以是Hibernate提供的 （奇了怪了这些定义好的为啥不各自分配一个注释？）</p>
<p>Hibernate提供的实现类</p>
<ul>
<li>IncrementGenerator 用数字类型添加主键 没有其他进程使用同一个数据库时使用</li>
<li>IdentityGenerator 实现自增长</li>
<li>SequenceStyleGenerator </li>
<li>。。。</li>
<li>UUIDGenerator 用UUID算法实现一个字符串类型的标识符</li>
<li>。。。。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"aa"</span>, strategy=<span class="string">"org.hibernate.id.xxxx"</span>)</span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator=<span class="string">"aa"</span>)</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>
<p>映射集合</p>
<p>Hibernate中持久化对象中的集合字段必须声明为接口，比如Set Collection List Map SortedSet SortedMap 甚至时自定义类型 （只要实现 UserCollectionType接口</p>
<p>Hibernate在持久化某个实例的时候，会自动把程序中的集合实现类替换成它自己的实现类，所以千万不要将集合属性转换为集合实现类HashMap等 但Set Map 可以</p>
<p>集合属性会跟随持久化对象持久化，当持久化对象删除时，集合属性的内容也会删，将集合从一个持久化对象移动到另一个对象，集合元素的数据记录也会从一个表移动到下一个</p>
<p>我们采用注解 @ElementCollection 进行标记</p>
<ul>
<li>fetch FetchType.LAZY/EAGER</li>
<li>targetClass 集合元素的类型</li>
</ul>
<p>由于集合元素常要保存另一个数据表，所以需要一个@CollectionTable 代表保存集合属性的表 和外键列 @JoinColumn</p>
<p>@CollectionTable</p>
<ul>
<li>name</li>
<li>catalog schema</li>
<li>indexes</li>
<li>joinColumns       该属性值实要一个注解为@JoinColumn 的数组/单个元素   每个元素映射一个外键列</li>
<li>uniqueConstraints</li>
</ul>
<p>@JoinColumn 定义外键列  常用的部分的  其实都是部分的属性</p>
<ul>
<li>name 外间列名字</li>
<li>columnDefinition 指定Hibernate使用该属性指定的SQL片段创建外键列</li>
<li>table 指定列所在数据表的表名</li>
<li>unique 是否为该列添加唯一约束</li>
<li>referencedColumnName 指定该列参照的主键列的列名</li>
</ul>
<p>存储集合类型分成三种 List  Set  Map</p>
<p>@OrderColumn 定义List和数组的索引</p>
<ul>
<li>集合元素是基本类型及其包装类型字符串日期 用@ElementCollection映射集合 并且用普通的@Column映射集合元素对应的列</li>
<li>集合元素是组件 （非持久化的类（复合类型））就用@Element Collection + @Embeddable 修饰非持久类</li>
<li>集合元素是关联的持久化实体，这时候就要用@OneToMany @ManyToMany 进行关联什么的</li>
</ul>
<p>下面是List作为属性的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=String.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"school_inf"</span>,joinColumn=<span class="meta">@JoinColumn</span>(name=<span class="string">"person_id"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"school_name"</span>)</span><br><span class="line"><span class="meta">@OrderColumn</span>(name=<span class="string">"list_order"</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; schools =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>从上面分析一下构建的思路</p>
<ol>
<li>@ElementCollection 首先表明下面是个集合属性 而且value targetClass 中可以指明集合元素中的类型</li>
<li>由于集合是要单独放在一个表中，所以要用@CollectionTable 构建表 name代表表名 joinColumn 指明外键，要注意这个外键是放在集合所在表中，name是取外键列的名字  但实际上是主表的哪一列呢？我猜测是默认取主键列！</li>
<li>设置@Column给自己的集合元素存放信息的列</li>
<li>@OrderColumn 由于是有序集合 添加一个索引列，它会自动帮你完成索引内容的填充</li>
<li>列集合属性要用接口来声明  但要用具体类实例化</li>
</ol>
<p>这样我们持久化什么之类以后          就会多一个school_inf表 表示集合  并且表中会让外键列和索引列作为联合主键</p>
<p>题外话有一种奇怪的打开Session方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session=HibernateUtil.currentSession();</span><br><span class="line">....</span><br><span class="line">HibernateUtil.closeSession();</span><br></pre></td></tr></table></figure>
<p>数组和List完全一样不过没搞明白的是它是<code>private String[]schools;</code>  并没有实例化？？？？？然后他说数组和List的区别在于数组的长度不可变？？</p>
<p>Set和List的区别也不大，就是Set不用设置@OrderColumn  Set其他和List一样 具体实例化是 <code>Set&lt;String&gt;ss=new HashSet&lt;&gt;()</code>  不过注意要再@Column中添加nullable=false  保证元素列不为空  因为Set的表由于没有索引列，则默认采取外键和元素列作为联合主键。如果没有这么写则该表没有主键</p>
<p>Map</p>
<ul>
<li>ElementCollection</li>
<li>CollectionTable</li>
<li>Column</li>
</ul>
<hr>
<ul>
<li>MapKeyColumn</li>
<li>MapKeyClass</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=Float.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"xx_inf"</span>,joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"xxid"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"aa"</span>)</span><br><span class="line"><span class="meta">@MapKeyColumn</span>(name=<span class="string">"aa_key"</span>)</span><br><span class="line"><span class="meta">@MapKeyClass</span>(String.class)</span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Float&gt;xxx=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Map表中取外键和key列作为联合主键</p>
<p>集合属性通常推荐使用 延迟加载策略，Hibernate对集合属性默认采用延迟加载，在某些情况下可以</p>
<p>@ElementCollection(fetch=FetchType.EAGER) 取消延迟加载</p>
<p>有序集合：集合元素可以根据key或index访问</p>
<p>无序集合：集合里的元素只能遍历</p>
<p>Hibernate </p>
<p>并不会立即更新该元素对应的数据行，因此对于Set集合而言，只有执行插入和删除操作时改变才有效</p>
<p>一般来说1-N的关联关系来说一般1会放弃控制权，所有的更新操作都会放在N一端进行处理。</p>
<p>而未初始化集合元素（从数据库中获取）情况下直接向List集合中添加新元素是正确的，总是可行的。然而Set不同，由于要保证元素不能重复，则要加入新元素时需要加载Set对象 性能就受到影响</p>
<p>Hibernate 删除集合的元素的时候如果删除全部元素，就直接整个集合delete就行，但如果是删剩下一条的话，就会一条条删然后就剩下那条。但其实其实作为开发者，你可以先delete整个集合然后再insert一条记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; tmp=person.getSchools();   <span class="comment">//返回一个String集合</span></span><br><span class="line">person.setSchools(<span class="keyword">null</span>);  <span class="comment">//调用delete删除person的关联的全部集合元素</span></span><br><span class="line"><span class="comment">//....对tmp这个List集合进行删除19个元素什么的</span></span><br><span class="line">person.setSchools(tmp);        <span class="comment">//进行insert的一个操作</span></span><br></pre></td></tr></table></figure>
<p>集合的元素可以当作“从属于”（感觉不是真正意义上的从属因为不是关联）主表的实体，所以主类的记录删除，集合中相应的记录也会删除。而且Hibernate无法直接加载和查询集合属性表的记录，必须先加载主类实体再通过主类实体去加载</p>
<h2 id="有序集合映射"><a href="#有序集合映射" class="headerlink" title="有序集合映射"></a>有序集合映射</h2><p>除了List，Hibernate SortedSet 和 SortedMap  两个有序集合，</p>
<ul>
<li><p>当需要映射这种有序集合必须 @SortNatural 或者 @SortComparator 注解 前者表明对集合元素采用默认的排序，后者则表明对集合元素采用自定义排序</p>
</li>
<li><p>@SortComparator 必须指定value 值为Comparator的实现类</p>
</li>
<li><p>而实例化SortedSet 和SortedMap 则用 TreeSet 和 TreeMap</p>
</li>
<li>其他的之前介绍的集合属性的注解也不能漏</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=String.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"person_id"</span>,joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"person_id"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"xxxvalue"</span>,nullable=<span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@SortNatural</span></span><br><span class="line"><span class="keyword">private</span> SortedSet&lt;String&gt; train=<span class="keyword">new</span> TreeSet&lt;&gt;();    </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是SortedMap 就要加上一些@MapKeyColumn  @MapKeyClass 这种 并且实例化为TreeMap</span></span><br></pre></td></tr></table></figure>
<p>其实所谓有序是按照插入顺序，先来的就排在前面 默认排序下（@SortNatural）</p>
<p>不过的话，要保证hibernate.cfg.xml 中的hbm2.auto属性为update，保证添加元素不会导致重建表</p>
<p>这样一个主类对象就可以添加多个集合元素并存储在表中</p>
<p>实际上我们如果想要集合所谓的字符比较排序的话 可以@OrderBy来进行注解</p>
<p>需要JDK 1.4以上 它实在SQL查询中进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ElementCollection</span>(targetClass=String.class)</span><br><span class="line"><span class="meta">@CollectionTable</span>(name=<span class="string">"xx_inf"</span>,joinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"xx_id"</span>,nullable=<span class="keyword">false</span>))</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"xxxvalue"</span>)</span><br><span class="line"><span class="meta">@OrderBy</span>(<span class="string">"xxxxvalue desc"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; tt=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>@OrderBy 导致的改变是在sql查询的时候添加了  order by xxxxvalue desc 子句</p>
<h3 id="映射表中建立对象"><a href="#映射表中建立对象" class="headerlink" title="映射表中建立对象"></a>映射表中建立对象</h3><p>如果希望在映射文件中创建删除触发器存储过程等数据库对象， 一般来说我们用不到映射文件因为我们是用注解的</p>
<p>注意映射文件不是hibernate.cfg.xml  而是创建某个类中定义的文件 比如     class A  对应的映射文件A.hbm.xml文件</p>
<p>看网上感觉<a href="http://blog.sina.com.cn/s/blog_86f4502c0101fm8l.html好像是一个映射文件就要一个类对应，所以就建个空类吧嘻嘻" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_86f4502c0101fm8l.html好像是一个映射文件就要一个类对应，所以就建个空类吧嘻嘻</a></p>
<p>这时候你就可以使用<code>&lt;database-object&gt;</code>标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.hbm.xml</span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span>   <span class="comment">&lt;!--这是根元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">database-object</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">create</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">create</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">drop</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">drop</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要在指定数据库方言下才有效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dialect-scope</span> <span class="attr">name</span>=<span class="string">"org.hibernate.MySQL5Dialect"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dialect-scope</span> <span class="attr">name</span>=<span class="string">"org.hibernate.MySQL5InnoDBDialect"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">database-object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>create中上的内容就是以完整的DDL的语句  要配上分号</p>
<p>比如创建一个表 创建一个触发器  create table test(xxname varchar(233));</p>
<p>而drop也定义了删除指定数据库对象的DDL   怀疑是drop一个表什么的</p>
<p>方法二 我们也可以不用create 和drop 直接在 <code>&lt;database-object&gt;</code>中 添加<code>&lt;definition class=&quot;xxx&quot;&gt;</code> 这个类必须实现 org.hibernate.mapping.AuxiliaryDatabaseObject 接口 它直到如何组织create 和drop命令</p>
<p>注意实际上我们在hibernate.cfg.xml文件中要指明映射文件</p>
<p><code>&lt;mapping resource=&quot;xxx/a.hbm.xml&quot;&gt;&lt;/mapping&gt;</code></p>
<p>而且注意修改属性</p>
<p><code>&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;</code></p>
<p>然后我们就按照之前的获取Configuration 然后创建什么SessionFactory 就行了 甚至不用获取一个session  在创建SessionFactory对象时就会生成映射文件对应的数据库对象</p>
<p>不过下面提供一个Hibernate 5.x 推荐的创建SessionFactory方式  前面是传统创建方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StandardServiceRegistry registry =<span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line">Metadata metadata=<span class="keyword">new</span> MetadataSources(registry).buildMetadata();</span><br><span class="line">metadata.buildSessionFactory();   <span class="comment">//采用Metadata去创建SessionFactory</span></span><br></pre></td></tr></table></figure>
<p>感觉有点点复杂 </p>
<p>EnumSet 是一个接口好像 然后是抽取这是一个高性能集合实现，比HashSet快得多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">要求元素必须是枚举类型</span></span><br></pre></td></tr></table></figure>
<p>每个EnumSet实例的所有元素必须是单个枚举类型的元素。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Java program to illustrate working of EnumSet and</span></span><br><span class="line"><span class="comment">// its functions.</span></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">enum</span> Gfg </span><br><span class="line">&#123;</span><br><span class="line">    CODE, LEARN, CONTRIBUTE, QUIZ, MCQ</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// create a set</span></span><br><span class="line">        EnumSet&amp;lt;Gfg&amp;gt; set1, set2, set3, set4;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// add elements</span></span><br><span class="line">        set1 = EnumSet.of(Gfg.QUIZ, Gfg.CONTRIBUTE, Gfg.LEARN, Gfg.CODE);</span><br><span class="line">        <span class="comment">//创建一个具有与指定枚举集相同元素类型的枚举集，最初包含此类型中未包含在指定集中的所有元素。</span></span><br><span class="line">        set2 = EnumSet.complementOf(set1); </span><br><span class="line">        <span class="comment">//创建一个包含指定元素类型中所有元素的枚举集</span></span><br><span class="line">        set3 = EnumSet.allOf(Gfg.class);</span><br><span class="line">        <span class="comment">//创建最初包含由两个指定端点定义的范围内的所有元素的枚举集</span></span><br><span class="line">        set4 = EnumSet.range(Gfg.CODE, Gfg.CONTRIBUTE);</span><br><span class="line">        System.out.println(<span class="string">"Set 1: "</span> + set1);</span><br><span class="line">        System.out.println(<span class="string">"Set 2: "</span> + set2);</span><br><span class="line">        System.out.println(<span class="string">"Set 3: "</span> + set3);</span><br><span class="line">        System.out.println(<span class="string">"Set 4: "</span> + set4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Set <span class="number">1</span>: [CODE, LEARN, CONTRIBUTE, QUIZ]</span><br><span class="line">Set <span class="number">2</span>: [MCQ]</span><br><span class="line">Set <span class="number">3</span>: [CODE, LEARN, CONTRIBUTE, QUIZ, MCQ]</span><br><span class="line">Set <span class="number">4</span>: [CODE, LEARN, CONTRIBUTE]</span><br></pre></td></tr></table></figure>
<p>实际上如果只是将其根据映射文件来生成数据库对象 可以使用SchemaExport工具 而不一定要需要创建会话工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.hibernate.service.ServiceRegistry serviceRegistry = <span class="keyword">new</span> StandardServiceRegistryBuilder().configure().build();</span><br><span class="line">Metadata metadata = <span class="keyword">new</span> MetadataSources(serviceRegistry).buildMetadata();</span><br><span class="line">SchemaExport schemaExport = <span class="keyword">new</span> SchemaExport();		schemaExport.create(EnumSet.of(TargetType.DATABASE), metadata);</span><br><span class="line"><span class="comment">//或者  我不知道这个是只给出文档不创建数据库 还是又创建数据库又创建文档，感觉像后者</span></span><br><span class="line"><span class="comment">//我想是的因为 create函数是只执行create table操作 而text是仅生成sql脚本而不生成实际对象</span></span><br><span class="line">schemaExport.setFormat(<span class="keyword">true</span>).setOutputFile(<span class="string">"news.sql"</span>).create(EnumSet.of(TargetType.SCRIPT),metadata);</span><br></pre></td></tr></table></figure>
<p>TargetType 是一个枚举类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">enum</span> TargetType &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// * Export to the database.   //感觉这个才是创建数据库的  （好像只是创建数据库？）</span></span><br><span class="line">    DATABASE,</span><br><span class="line">     <span class="comment">//* Write to a script file.</span></span><br><span class="line">    SCRIPT,</span><br><span class="line">     <span class="comment">//* Write to &#123;@link System#out&#125;   //输出屏幕的样子</span></span><br><span class="line">    STDOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上SchemaExport 甚至执行它的main函数，它提供很多不同的参数功能，我想这些在代码中有相应的函数</p>
<p>p430</p>
<p>组件属性 </p>
<p>就是作为一个类做其他类属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"person_inf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    xxxx</span><br><span class="line">    <span class="keyword">private</span> Name name;   <span class="comment">//name 是一个类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让name成为一个组件属性使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"person_firstname"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fitst;</span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"person_secondname"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Parent</span></span><br><span class="line">    <span class="keyword">private</span> Person owner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NAme</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        first=s1;</span><br><span class="line">        second=s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略setter和getter的东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过上面实例可以知道映射组件属性需要做到的几点</p>
<ul>
<li>@Embeddable  注释整个组件类</li>
<li>@Column 注释组件类中的属性，将来是将这些属性拆开成一列列数据而已</li>
<li>@Parent 这个挺特别的 组件类中要有一个主人类的一个对象指向的就是Name主人的实体，而且要用@Parent注释它，估计注释后到时就会给这个owner自动赋值</li>
</ul>
<p>然后使用过程中就当Name是person的一个普通属性即可</p>
<p>最后这个组件属性并不是另外创建一个表，而是将其内容拆开，其一个个属性成为一列列补充在person_inf 中</p>
<p>实际上也有另外一种注释方法，不在组件类中进行属性 直接在持久化类进行注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    xx</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">            <span class="meta">@AttributeOverride</span>(name=<span class="string">"first"</span>,column=<span class="meta">@Column</span>(name=<span class="string">"person_firstname"</span>))</span><br><span class="line">            <span class="meta">@AttributeOverride</span>(name=<span class="string">"second"</span>,column=<span class="meta">@Column</span>(name=<span class="string">"person_lastname"</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">   <span class="keyword">private</span> Name name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Embedded注解</p>
<p>@AttrbuteOverrides下包含多个@AttributeOverride 里面name指明属性名 column指明映射的列的名字</p>
<p>但我觉得是不是组件类不用说明@Parent了？？？</p>
<p>如果<strong>组件属性类中的属性有那种集合类型</strong> 其实就不用对他进行什么操作，之前怎么做就怎么安排</p>
<p>实际上我们从底层数据库是看不出 这个集合的数据表 是数据person类 还是属于name类的，但其实没关系，毕竟如果属于name的话也是属于person的</p>
<p><strong>集合属性的元素为类</strong></p>
<p>比如<code>private List&lt;Name&gt;x=new ArrayList&lt;&gt;();</code>  <code>private Map&lt;String,Name&gt;x=new HashMap&lt;&gt;();</code></p>
<p>其他照旧 讲一下区别   程序不在用@Column映射为保存集合元素 而是用@Embeddable修饰组件类（Name）</p>
<p>组件类该干嘛干嘛</p>
<p>这样底层表的区别是  集合的那个表 由一列表示值变成多列表示值</p>
<p><strong>组件作为Map的索引</strong></p>
<p>这个时候@Column就要重出江湖，因为组件类不充当值了，而@MapKeyClass 就最好要明确指明类型</p>
<p>而且由于作为Map的key，所以这个组件类除了各种注解什么的 还要重写 equals 和 hashCode方法</p>
<p>在底层的表中 Map的映射表 会将外键列和Name属性对应的多个列 组成联合主键</p>
<p><strong>组件作为复合(联合)主键</strong></p>
<p>作为复合主键，对于组件类有了更高的要求</p>
<ul>
<li>有无参数构造器</li>
<li>必须实现java.io.Serializable  其实也是实现boolean equals(Object obj) 和 int hashCode()</li>
<li>重写equals和hashCode方法，定义来区分对象的规则</li>
</ul>
<p>这里给出的组件类的注解是写在持久化类中 所以不知道组件类注解是否可行????????????????????</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@EmbeddedId</span>             <span class="comment">//不是@Embedded</span></span><br><span class="line">    <span class="meta">@AttributeOverrides</span>(&#123;</span><br><span class="line">        xxxxx</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多列作为联合主键</strong></p>
<p>其实比起将一个组件属性类当作一个复合主键，让多个列形成联合主键这种情况更加常见</p>
<ul>
<li>持久化类实现 java.io.Serializable接口</li>
<li>实现hashCode()和equals(Object obj)</li>
<li>然后将你想要的普通属性加上@Id  如果是那些特殊的组件类的请看上面</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/23/big-endian和little-endian/" rel="next" title="big-endian和little-endian">
                <i class="fa fa-chevron-left"></i> big-endian和little-endian
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/23/hibernate学习（二）持久化类/" rel="prev" title="hibernate学习（二）持久化类">
                hibernate学习（二）持久化类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen JianLun</p>
              <p class="site-description motion-element" itemprop="description">Embrace the trend</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库映射"><span class="nav-number">1.</span> <span class="nav-text">数据库映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合映射"><span class="nav-number"></span> <span class="nav-text">有序集合映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#映射表中建立对象"><span class="nav-number">1.</span> <span class="nav-text">映射表中建立对象</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen JianLun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
